grammar msi.gama.lang.gaml.Gaml hidden(WS, ML_COMMENT, SL_COMMENT)

import "http://www.eclipse.org/emf/2002/Ecore" as ecore
generate gaml "http://www.gama.msi/lang/gaml/Gaml"

Model:
	'model' name=ID (imports+=Import)* (statements+=Statement)*;

Import:
	'import' importURI=STRING; // must be named importURI
	
BuiltInStatementKey:
	//Statements that accept an expression as their "default" facet
	'add' |
	'ask' |
	'capture' |
	'create' |
	'draw' |
	'error'|
	'match' |
	'match_between' |
	'match_one' |
	'put' |
	'release' |
	'remove' |
	'save' |
	'set' |
	'switch'|
	'warn'|
	'write';

/**
 * Statements 
 */
Statement:
	=>AssignmentStatement | (ReturnStatement | IfStatement  | ClassicStatement | DefinitionStatement );

//SetStatement returns Statement:
//	key='set' var=Access ('<-'|'value:') expr=Expression ';'
//	/*| (var=(MemberRef|Access) key=':=' expr=Expression ';') */; // enable "name=ID '<-' expr=Expression ';'" ? 
IfStatement returns Statement:
	key='if' ('condition:')? expr=Expression block=Block (=> 'else' else=(IfStatement | Block))?;

ClassicStatement returns Statement:
	key=BuiltInStatementKey (ID':')? expr=Expression (facets+=Facet)* (block=Block | ';');

DefinitionStatement returns Statement:
	(key=ID) of=Contents? name=(ID | STRING | BuiltInStatementKey)? (facets+=Facet)* (block=Block | ';');
	
Contents: ('<' type=ID (',' type2= ID)? '>');

ReturnStatement returns Statement:
	key='return' expr=Expression? ';';

AssignmentStatement returns Statement:
	expr= Expression key=("<-"|"<<"|">>"|"+="|"-=" | "++" | "--"|":=") value=Expression (facets+=Facet)*';';

/**
 * Facets
 */


Facet:
	FunctionFacet | DefinitionFacet | ClassicFacet;

ClassicFacet returns Facet:
	(key=ID ':' | key='<-') expr=Expression;

FunctionFacet returns Facet:
	(key='function:' | key='->') '{' expr=Expression '}';

/*
 * Definition facets (which are used for cross referencing variables)
 */
DefinitionFacetKey: 'name:' | 'returns:'|'action:';
DefinitionFacet returns Facet:
	(key=DefinitionFacetKey) name=(ID | STRING | BuiltInStatementKey);

/**
 * Blocks. An ordered list of statements inside curly brackets
 */
Block:
	{Block} '{' (statements+=Statement)* '}';

	/**
 * Expressions
 */
Expression:
	TernExp;

TernExp returns Expression:
	OrExp
	({TernExp.left=current}
	op='?'
	right=OrExp
	':'
	ifFalse=OrExp)?;

OrExp returns Expression:
	AndExp
	({Expression.left=current}
	op='or'
	right=AndExp)*;

AndExp returns Expression:
	Relational
	({Expression.left=current}
	op='and'
	right=Relational)*;

Relational returns Expression:
	PairExpr
	(({Expression.left=current}
	op=('!=' | '=' | '>=' | '<=' | '<' | '>'))
	right=PairExpr)?;

ArgPairExpr returns PairExpr:
	{ArgPairExpr} (arg=ID op='::' | arg=DefinitionFacetKey op=':') right=Addition;

PairExpr returns Expression:
	=> ArgPairExpr |
	Addition
	(({PairExpr.left=current}
	op='::')
	right=Addition)?;

Addition returns Expression:
	Multiplication
	(({Expression.left=current} op=('+' | '-'))
	right=Multiplication)*;

Multiplication returns Expression:
	GamlBinaryExpr /*Access */
	(({Expression.left=current} op=('*' | '/' | '^')) right=GamlBinaryExpr/*Access */)*;

GamlBinaryExpr returns Expression:
	GamlUnitExpr
	(({GamlBinaryExpr.left=current} op=ID) right=GamlUnitExpr)*;

	// NEW: Units can now be expressed using the "¡" symbol (in addition to "#")
GamlUnitExpr returns Expression:
	GamlUnaryExpr
	(({GamlUnitExpr.left=current} op=('#' | '¡')) right=UnitName)?;

GamlUnaryExpr returns Expression:
	Access |
	{GamlUnaryExpr} ({GamlUnaryExpr.left=current} (op='¡' right=UnitName) | (op=('-' | '!' | 'my' | 'the' | 'not')
	right=GamlUnaryExpr));
	
		
Access returns Expression:
	MemberRef (({Access.left=current} '[') args+=Expression (',' args+=Expression)* ']')*;

//PrePrimaryExpr returns Expression:
//	TerminalExpression | MemberRef;

MemberRef returns Expression:
	PrimaryExpression ({MemberRef.left=current} (op='.' right=PrimaryExpression))*;

PrimaryExpression returns Expression:
	TerminalExpression |
	AbstractRef | 
	'(' Expression ')' | 
	'[' {Array} (exprs+=Expression (',' exprs+=Expression)*)? ']' | 
	'{' {Point} left=Expression op=',' right=Expression (',' z=Expression)? '}';

AbstractRef returns Expression:
	VariableRef | Function;

Function returns Expression:
	{Function} (op=ID '(' args+=Expression (',' args+=Expression)* ')');



	/**
 * Cross-references to variables/operators/units
 */
UnitName returns Expression:
	{UnitName} op=ID;

VariableRef returns Expression:
	{VariableRef} ref=[GamlVarRef];
	
	//TypeRef: ref=[BuiltInType];
GamlVarRef:
	DefinitionFacet | DefinitionStatement;

	/**
 * Terminals
 */
TerminalExpression:
	{IntLiteral} value=INTEGER | {DoubleLiteral} value=DOUBLE | {ColorLiteral} value=COLOR | {StringLiteral} value=STRING
	| {BooleanLiteral} value=BOOLEAN;

terminal INTEGER:
	'0' | ('1'..'9' ('0'..'9')*);

terminal BOOLEAN:
	'true' | 'false';

terminal ID:
	('a'..'z' | 'A'..'Z' | '_' | '$') ('a'..'z' | 'A'..'Z' | '_' | '$' | '0'..'9')*;

terminal COLOR:
	'#' ('0'..'9' | 'A'..'F')+;

terminal DOUBLE:
	'1'..'9' ('0'..'9')* ('.' '0'..'9'+)? (('E' | 'e') ('+' | '-')? '0'..'9'+)? | '0' ('.' '0'..'9'+)? (('E' | 'e') ('+' |
	'-')? '0'..'9'+)?;

terminal STRING:
	'"' ('\\' ('b' | 't' | 'n' | 'f' | 'r' | 'u' | '"' | '\\') | !('\\' | '"'))* '"' | "'" ('\\' ('b' | 't' | 'n' | 'f' |
	'r' | 'u' | "'" | '\\') | !('\\' | "'"))* "'";

terminal ML_COMMENT:
	'/*'->'*/';

terminal SL_COMMENT:
	'//' !('\n' | '\r')* ('\r'? '\n')?;

terminal WS:
	(' ' | '\t' | '\r' | '\n')+;

terminal ANY_OTHER:
	.;
