grammar msi.gama.lang.gaml.Gaml hidden(WS, ML_COMMENT, SL_COMMENT)

import "http://www.eclipse.org/emf/2002/Ecore" as ecore
generate gaml "http://www.gama.msi/lang/gaml/Gaml"

Model :
	'model' name=ID
	(imports+=Import)*
	(('_gaml {{' gaml=GamlLangDef '}}')? 
	(statements+=Statement)*) ;


Import :
	'import' 
	 // feature must be named importURI
	importURI=STRING;


// META-GRAMMAR: used to parse the tokens introduced automatically in the imports by GAMA



GamlLangDef:
	( k+=DefKeyword | f+=DefFacet | b+=DefBinaryOp | r+=DefReserved | u+=DefUnit | unaries+=DefUnary )+;

DefKeyword:
	 (('_keyword &'|'_definition &') name=ID'&;')/* (block=GamlBlock|';')*/;
//GamlBlock:
//	'{{'
//		{GamlBlock}
//		('_facets' '[' facets+=[DefFacet]    (',' facets+=[DefFacet])*    ']')?
//		('_children' '[' childs+=[DefKeyword]  (',' childs+=[DefKeyword])*  ']')?
//	'}}';
DefFacet:
	('_facet &'  name=ID '&;');
DefBinaryOp:
	'_binary &' name=ID'&;';
DefReserved:
	'_reserved &' name=ID'&;';
DefUnary:
	'_unary &'name=ID '&;';
DefUnit:
	'_unit &'name=ID'&;';


// Built-in keywords (which are not provided by the annotation processor)

GamlBuiltInKeyword: (IF | ELSE | LOOP | RETURN | SET | DO | ITEM | CREATE | TARGET);


 IF: 'if';
 ELSE: 'else';
 LOOP: 'loop';
 RETURN: 'return';
 SET: 'set';
 DO: 'do';
 ITEM: ('add'|'remove'|'put'|'save');
 CREATE: 'create';
 TARGET: ('capture'|'release'|'ask');
 


AbstractGamlRef: // for highlight
	GamlFacetRef | GamlKeywordRef | GamlBinarOpRef | GamlUnitRef | GamlReservedRef;
GamlKeywordRef: // for highlight
	(ref=[DefKeyword]);
GamlFacetRef hidden():
	ref=[DefFacet] ':';
GamlBinarOpRef:
	ref=[DefBinaryOp];
GamlUnitRef:
	ref=[DefUnit];
GamlReservedRef:
	ref=[DefReserved];
GamlUnaryRef:
	ref=[DefUnary];

Statement:
	SpecialStatement | Definition;
	
	
SpecialStatement:
	SetEval | LoopEval | ReturnEval | IfEval | DoEval | ItemEval | CreateEval | TargetEval;

IfEval:
	key=IF ref=GamlFacetRef? expr=Expression block=Block (ELSE else=Block)?;
	
ReturnEval:
	key=RETURN ref=GamlFacetRef? (expr=Expression)? ';';

LoopEval:
	key=LOOP (name=ID)? (facets+=FacetExpr)+ block=Block;

SetEval:
	key=SET ref=GamlFacetRef? arg=Expression refValue=GamlFacetRef expr=Expression ';';
	
DoEval:
	key=DO ref=GamlFacetRef? action=ID (args+=ArgExpr)* facets+=ReturnsFacetExpr? (block=Block | ';');
ItemEval:
	key=ITEM ref=GamlFacetRef? item=Expression (facets+=FacetExpr)+ (block=Block | ';');
CreateEval:
	key=CREATE ref=GamlFacetRef? species=Expression (facets+=FacetExpr)* (block=Block | ';');
TargetEval:
	key=TARGET ref=GamlFacetRef? target=Expression (facets+=FacetExpr)* (block=Block | ';');

ArgExpr:
	key=ID ':' expr=Expression
;

Definition: // const/var/let/species/grid/gis/state/arg
	key=GamlKeywordRef (name=ID)? (facets+=FacetExpr)* (block=Block | ';');

//Evaluation:
//	key=GamlKeywordRef /*(':' arg=Expression)? */ (facets+=FacetExpr)* (block=Block | ';');

FacetExpr:
	ReturnsFacetExpr | (key=GamlFacetRef expr=Expression);

ReturnsFacetExpr:
	'returns:' name=ID;
	
Block:
	{Block} '{' (statements+=Statement)* '}';

AbstractDefinition: // for variable reference
	Definition | DefFacet | DefUnit | DefReserved | ReturnsFacetExpr | LoopEval | DefUnary /*for types */;

Expression:
	TernExp;

TernExp returns Expression:
	OrExp ({Ternary.condition=current} '?' ifTrue=OrExp ':' ifFalse=OrExp)?; 

OrExp returns Expression:
	AndExp ({Or.left=current} 'or' right=AndExp)*;

AndExp returns Expression:
	Relational ({And.left=current} 'and' right=Relational)*;

Relational returns Expression:
	PairExpr
	(
		( {RelNotEq.left=current}'!='
		| {RelEq.left=current}   '='
//		| {RelEqEq.left=current} '=='
		| {RelLtEq.left=current} '>='
		| {RelGtEq.left=current} '<='
		| {RelLt.left=current}   '<'
		| {RelGt.left=current}   '>' )
	right=PairExpr
	)?;

PairExpr returns Expression:
	Addition (({Pair.left=current}'::') right=Addition)?;

Addition returns Expression:
	Multiplication (({Plus.left=current}'+'|{Minus.left=current}'-') right=Multiplication)*;

Multiplication returns Expression:
	GamlBinExpr (({Multi.left=current}'*'|{Div.left=current}'/'|{Pow.left=current}'^') right=GamlBinExpr)*;

GamlBinExpr returns Expression:
	GamlUnitExpr (({GamlBinary.left=current} op=GamlBinarOpRef) right=GamlUnitExpr)*;

GamlUnitExpr returns Expression:
	GamlUnaryExpr (({Unit.left=current}'#') right=GamlUnitRef)?;

GamlUnaryExpr returns Expression:
	PrePrimaryExpr | 
	{GamlUnary} (op=UnarOp right=GamlUnaryExpr);
UnarOp:
	'-' |
	'!' |
	'my'  |
	'the' |
	'not' ;
// conflict between unary and binary
// see http://www.eclipse.org/forums/?t=msg&th=169692

PrePrimaryExpr returns Expression:
	TerminalExpression | RightMemberRef | MemberRef; 

MemberRef returns Expression:
	PrimaryExpression ({MemberRefP.left=current} '.' right=RightMemberRef)?;

PrimaryExpression returns Expression:
	'('Expression')' |
	'[' Matrix ']' |
	'{' Point  '}';

Point:
	x=Expression ',' y=Expression;

Matrix: {Matrix}
	(rows+=Row (';' rows+=Row)*)?;
Row:
	exprs+=Expression (',' exprs+=Expression)*;

RightMemberRef returns Expression:
	AbstractRef ({MemberRefR.left=current} '.' right=RightMemberRef)?;

AbstractRef returns Expression:
	VariableRef
		(
			({FunctionRef.func=current} '('(args+=Expression (',' args+=Expression)*)?')' ) 
			| ({ArrayRef.array=current} '['(args+=Expression (',' args+=Expression)*)?']' )
		)?;

VariableRef:
	ref=[AbstractDefinition];

TerminalExpression:
	{IntLiteral}     value=INT     |
	{DoubleLiteral}  value=DOUBLE  |
	{ColorLiteral}   value=COLOR   |
	{StringLiteral}  value=STRING  |
	{BooleanLiteral} value=BOOLEAN ;

// -----


terminal INT returns ecore::EInt:
	'0' | ('1'..'9' ('0'..'9')*);

terminal BOOLEAN returns ecore::EBoolean:
	'true' | 'false';

terminal ID :
	('a'..'z'|'A'..'Z'|'_'|'0'..'9')+ ('$' ('a'..'z'|'A'..'Z'|'_'|'0'..'9')+)?;


terminal COLOR:
	'#' ('0'..'9'|'A'..'F')+ ;

// @see http://java.sun.com/javase/6/docs/api/java/lang/Double.html#valueOf(java.lang.String)
terminal DOUBLE:// returns ecore::EDouble : 
	'1'..'9' ('0'..'9')* ('.' '0'..'9'+)? (('E' | 'e') ('+' | '-')? '0'..'9'+)?
	| '0' ('.' '0'..'9'+)? (('E' | 'e') ('+' | '-')? '0'..'9'+)? ;

terminal STRING :
	'"' ( '\\' ('b'|'t'|'n'|'f'|'r'|'u'|'"'|'\\') | !('\\'|'"') )* '"' |
	"'" ( '\\' ('b'|'t'|'n'|'f'|'r'|'u'|"'"|'\\') | !('\\'|"'") )* "'" ; 

terminal ML_COMMENT	:
	'/*' -> '*/';

terminal SL_COMMENT :
	'//' !('\n'|'\r')* ('\r'? '\n')?;

terminal WS :
	(' '|'\t'|'\r'|'\n')+;

terminal ANY_OTHER : .;
