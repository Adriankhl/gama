grammar msi.gama.lang.gaml.Gaml hidden(WS, ML_COMMENT, SL_COMMENT)

import "http://www.eclipse.org/emf/2002/Ecore" as ecore
generate gaml "http://www.gama.msi/lang/gaml/Gaml"

	Model : 'model' name=ID (imports+=Import)* (('_gaml {' gaml=GamlLangDef '}')? (statements+=Statement)* );
	Import : 'import' importURI=STRING; // must be named importURI

/**
 * MetaGrammar: used to parse the tokens introduced automatically in the imports by GAMA
 */ 
	GamlLangDef: (b+=DefBinaryOp | r+=DefReserved | unaries+=DefUnary )+;
	DefBinaryOp: '_binary &' name=ID'&;';
	DefReserved: '_reserved &' name=ID'&;';
	DefUnary: '_unary &'name=ID '&;';

/**
 * Built-in keywords (corresponding to special statements)
 */ 
	BuiltIn:  ('write'|'warn'|'error'|'match'|'match_one'|'match_between'|'capture'|'release'|'ask'|'switch'|'create'|'add'|'remove'|'put'|'save'|'set'|'return');

/**
 * Statements (i.e. commands in the GAML descriptions).
 */ 
	Statement: (IfEval | ClassicStatement | Definition);
	ClassicStatement returns Statement: key=BuiltIn ref=GamlFacetRef? expr=Expression (facets+=FacetExpr)* (block=Block | ';');
	IfEval returns Statement: key='if' ref=GamlFacetRef? expr=Expression block=Block (=>'else' else=(Statement | Block))?;
	Definition: key=ID (name=ID|name=STRING|name=BuiltIn)? (facets+=FacetExpr)* (block=Block | ';');

/**
 * Facets
 */ 
	FacetRef: GamlFacetRef | FunctionGamlFacetRef;
	GamlFacetRef:  ref = ID ':' | ref = '<-';
	FunctionGamlFacetRef:  (ref='function' ':'| ref = '->');
	FacetExpr:    FunctionFacetExpr | DefinitionFacetExpr | (key=GamlFacetRef expr=Expression);
	DefinitionFacetExpr: ReturnsFacetExpr | NameFacetExpr | ActionFacetExpr;
	NameFacetExpr: ('name:') (name=ID|name=STRING|name=BuiltIn);
	ReturnsFacetExpr : 'returns:' name=ID;
	ActionFacetExpr: 'action:' (name=ID|name=STRING|name=BuiltIn);
	FunctionFacetExpr: key= FunctionGamlFacetRef '{' expr=Expression '}'; // Introduce "closures" ? 

/**
 * Blocks. Just an ordered list of statements inside curly brackets
 */ 
	Block: {Block} '{' (statements+=Statement)* '}';

/**
 * Expressions
 */ 
	Expression: TernExp;
	TernExp returns Expression: OrExp ({TernExp.left=current} op='?' right=OrExp ':' ifFalse=OrExp)?; 
	OrExp returns Expression: AndExp ({Expression.left=current} op='or' right=AndExp)*;
	AndExp returns Expression: Relational ({Expression.left = current} op='and' right=Relational)*;
	Relational returns Expression: PairExpr (({Expression.left=current}op=('!='|'='|'>='|'<='|'<'|'>')) right=PairExpr)?;
	PairExpr returns Expression:   Addition (({PairExpr.left= current}op='::') right=Addition)?;
	Addition returns Expression: Multiplication (({Expression.left=current}op='+'|{Expression.left=current}op='-') right=Multiplication)*;
	Multiplication returns Expression: GamlBinaryExpr (({Expression.left=current}op='*'|{Expression.left=current}op='/'|{Expression.left=current}op='^') right=GamlBinaryExpr)*;
	GamlBinaryExpr returns Expression: GamlUnitExpr (({GamlBinaryExpr.left=current} op=ID) right=GamlUnitExpr)*;
	GamlUnitExpr returns Expression: GamlUnaryExpr (({GamlUnitExpr.left=current}op='#') right=UnitName)?;
	GamlUnaryExpr returns Expression: PrePrimaryExpr | {GamlUnaryExpr} ({GamlUnaryExpr.left=current}op=('-'|'!'|'my'|'the'|'not') right=GamlUnaryExpr);
	PrePrimaryExpr returns Expression: TerminalExpression | MemberRef; 
	MemberRef returns Expression : PrimaryExpression ({MemberRef.left=current} op='.' right=VariableRef)*;
	PrimaryExpression returns Expression: AbstractRef | '('Expression')' | '[' {Array}(exprs+=Expression (',' exprs+=Expression)*)? ']' | '{' {Point} (left=Expression op=',' right=Expression ) '}';
	AbstractRef returns Expression: VariableRef ({FunctionRef.left=current} '('args+=Expression (',' args+=Expression)*')')? ;

/**
 * Cross-references to variables/operators/units
 */
 	ArbitraryName returns Expression: {ArbitraryName} name = ID;
 	UnitName returns Expression: {UnitName} name= ID;
	VariableRef : {VariableRef} ref=[GamlVarRef];
	GamlVarRef: DefinitionFacetExpr | Definition | DefReserved | DefUnary /*| DefBinaryOp */;
	
	
	//SUPPRIMER DES CROSS_REFERENCES (units / unaries ? / reserved)

/**
 * Terminals
 */ 

	TerminalExpression: {IntLiteral} value=INTEGER | {DoubleLiteral}  value=DOUBLE  | {ColorLiteral}   value=COLOR   | {StringLiteral}  value=STRING  | {BooleanLiteral} value=BOOLEAN ;
	terminal INTEGER : '0' | ('1'..'9' ('0'..'9')*);
	terminal BOOLEAN : 'true' | 'false';
	terminal ID :  ('a'..'z'|'A'..'Z'|'_'|'0'..'9')+ ('$' ('a'..'z'|'A'..'Z'|'_'|'0'..'9')+)? ;
	terminal COLOR: '#' ('0'..'9'|'A'..'F')+ ;
	terminal DOUBLE: '1'..'9' ('0'..'9')* ('.' '0'..'9'+)? (('E' | 'e') ('+' | '-')? '0'..'9'+)? | '0' ('.' '0'..'9'+)? (('E' | 'e') ('+' | '-')? '0'..'9'+)? ;
	terminal STRING : '"' ( '\\' ('b'|'t'|'n'|'f'|'r'|'u'|'"'|'\\') | !('\\'|'"') )* '"' | "'" ( '\\' ('b'|'t'|'n'|'f'|'r'|'u'|"'"|'\\') | !('\\'|"'") )* "'" ; 
	terminal ML_COMMENT	: '/*' -> '*/';
	terminal SL_COMMENT : '//' !('\n'|'\r')* ('\r'? '\n')?;
	terminal WS : (' '|'\t'|'\r'|'\n')+;
	terminal ANY_OTHER : .;
