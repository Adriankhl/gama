grammar msi.gama.lang.gaml.Gaml hidden(WS, ML_COMMENT, SL_COMMENT)

import "http://www.eclipse.org/emf/2002/Ecore" as ecore
generate gaml "http://www.gama.msi/lang/gaml/Gaml"

Model :
	'model' name=FQN
	(imports+=Import)*
	(gaml=GamlLangDef)?
	(statements+=Statement)*;

Import :
	'import' 
	importURI=STRING; // feature must be named importURI

ImportedFQN:
	FQN ('.' '*')?;

GamlLangDef:
	'_gaml' '{' ( k+=DefKeyword | f+=DefFacet | b+=DefBinaryOp | r+=DefReserved | u+=DefUnit )+ '}';

DefKeyword:
	'_keyword' name=ID (block=GamlBlock|';');
GamlBlock:
	'{'
		{GamlBlock}
		('_facets' '[' facets+=[DefFacet]    (',' facets+=[DefFacet])*    ']')?
		('_children' '[' childs+=[DefKeyword]  (',' childs+=[DefKeyword])*  ']')?
	'}';
DefFacet:
	'_facet'   name=ID (':' type=[DefReserved])? ('=' default=TerminalExpression)? ';';
DefBinaryOp:
	'_binary'  name=ID ';';
DefReserved:
	'_reserved' name=ID (':' type=[DefReserved])? ('=' value=TerminalExpression)? ';';
DefUnit:
	'_unit' name=ID ('=' coef=DOUBLE)? ';';

AbstractGamlRef: // for highlight
	GamlFacetRef | GamlKeywordRef | GamlBinarOpRef | GamlUnitRef | GamlReservedRef;
GamlKeywordRef: // for highlight
	ref=[DefKeyword];
GamlFacetRef hidden():
	ref=[DefFacet] ':';
GamlBinarOpRef:
	ref=[DefBinaryOp];
GamlUnitRef:
	ref=[DefUnit];
GamlReservedRef:
	ref=[DefReserved];

Statement:
	SetEval | SubStatement; 
SubStatement:
	Definition | Evaluation;

SetEval:
	'set' var=Expression (facets+=FacetExpr)* (block=Block | ';');

Definition: // const/var/let/species/grid/gis/state/arg
	key=GamlKeywordRef name=ID (facets+=FacetExpr)* (block=Block | ';');

Evaluation:
	key=GamlKeywordRef (':' var=Expression)? (facets+=FacetExpr)* (block=Block | ';');

FacetExpr:
	('returns:' name=ID) | (key=GamlFacetRef expr=Expression);

Block:
	{Block} '{' (statements+=Statement)* '}';

AbstractDefinition: // for variable reference
	Definition | DefReserved | FacetExpr;

Expression:
	AssignmentOp;

AssignmentOp returns Expression:
	TernExp
	(
		({AssignPlus.left=current} '+=' 
		|{AssignMin.left=current}  '-=' 
		|{AssignMult.left=current} '*=' 
		|{AssignDiv.left=current}  '/=' )
	right=TernExp
	)?;

TernExp returns Expression:
	OrExp ({Ternary.condition=current} '?' ifTrue=OrExp ':' ifFalse=OrExp)?; 

OrExp returns Expression:
	AndExp ({Or.left=current} 'or' right=AndExp)*;

AndExp returns Expression:
	Relational ({And.left=current} 'and' right=Relational)*;

Relational returns Expression:
	PairExpr
	(
		( {RelNotEq.left=current}'!='
		| {RelEq.left=current}   '='
		| {RelEqEq.left=current} '=='
		| {RelLtEq.left=current} '>='
		| {RelGtEq.left=current} '<='
		| {RelLt.left=current}   '<'
		| {RelGt.left=current}   '>' )
	right=PairExpr
	)?;

PairExpr returns Expression:
	Addition (({Pair.left=current}'::') right=Addition)?;

Addition returns Expression:
	Multiplication (({Plus.left=current}'+'|{Minus.left=current}'-') right=Multiplication)*;

Multiplication returns Expression:
	GamlBinExpr (({Multi.left=current}'*'|{Div.left=current}'/') right=GamlBinExpr)*;

GamlBinExpr returns Expression:
	Power (({GamlBinary.left=current} op=GamlBinarOpRef) right=Power)*;

Power returns Expression:
	GamlUnitExpr (({Pow.left=current}'^') right=GamlUnitExpr)*;

GamlUnitExpr returns Expression:
	GamlUnaryExpr (({Unit.left=current}'#') right=GamlUnitRef)?;

GamlUnaryExpr returns Expression:
	PrePrimaryExpr | 
	{GamlUnary} (op=UnarOp right=GamlUnaryExpr);
UnarOp:
	'-' |
	'!' |
	'my'  |
	'the' |
	'not' ;
// conflict between unary and binary
// see http://www.eclipse.org/forums/?t=msg&th=169692

PrePrimaryExpr returns Expression:
	TerminalExpression | RightMemberRef | MemberRef; 

MemberRef returns Expression:
	PrimaryExpression ({MemberRefP.left=current} '.' right=RightMemberRef)?;

PrimaryExpression returns Expression:
	'('Expression')' |
	'[' Matrix ']' |
	'{' Point  '}';

Point:
	x=Expression ',' y=Expression;

Matrix: {Matrix}
	(rows+=Row (';' rows+=Row)*)?;
Row:
	exprs+=Expression (',' exprs+=Expression)*;

RightMemberRef returns Expression:
	AbrstractRef ({MemberRefR.left=current} '.' right=RightMemberRef)?;

AbrstractRef returns Expression:
	VariableRef
		(
			({FunctionRef.func=current} '('(args+=Expression (',' args+=Expression)*)?')' ) 
			| ({ArrayRef.array=current} '['(args+=Expression (',' args+=Expression)*)?']' )
		)?;

VariableRef:
	ref=[AbstractDefinition];

TerminalExpression:
	{IntLiteral}     value=INT     |
	{DoubleLiteral}  value=DOUBLE  |
	{ColorLiteral}   value=COLOR   |
	{StringLiteral}  value=STRING  |
	{BooleanLiteral} value=BOOLEAN ;

// -----

FQN : ID ('.' ID)*;

terminal INT returns ecore::EInt:
	'0' | ('1'..'9' ('0'..'9')*);

terminal BOOLEAN returns ecore::EBoolean:
	'true' | 'false';

terminal ID :
	('a'..'z'|'A'..'Z'|'_'|'0'..'9')+ ('$' ('a'..'z'|'A'..'Z'|'_'|'0'..'9')+)?;
	
	/*
terminal DELEGATION_ID : 
	ID ('$' ID)?;
	*/

terminal COLOR:
	'#' ('0'..'9'|'A'..'F')+ ;

// @see http://java.sun.com/javase/6/docs/api/java/lang/Double.html#valueOf(java.lang.String)
terminal DOUBLE:// returns ecore::EDouble : 
	'1'..'9' ('0'..'9')* ('.' '0'..'9'+)? (('E' | 'e') ('+' | '-')? '0'..'9'+)?
	| '0' ('.' '0'..'9'+)? (('E' | 'e') ('+' | '-')? '0'..'9'+)? ;

terminal STRING :
	'"' ( '\\' ('b'|'t'|'n'|'f'|'r'|'u'|'"'|'\\') | !('\\'|'"') )* '"' |
	"'" ( '\\' ('b'|'t'|'n'|'f'|'r'|'u'|"'"|'\\') | !('\\'|"'") )* "'" ; 

terminal ML_COMMENT	:
	'/*' -> '*/';

terminal SL_COMMENT :
	'//' !('\n'|'\r')* ('\r'? '\n')?;

terminal WS :
	(' '|'\t'|'\r'|'\n')+;

terminal ANY_OTHER : .;
