grammar msi.gama.lang.gaml.Gaml hidden(WS, ML_COMMENT, SL_COMMENT)

/**
 * A GAML grammar without cross references. 
 */

import "http://www.eclipse.org/emf/2002/Ecore" as ecore
generate gaml "http://www.gama.msi/lang/gaml/Gaml"

	Model : 'model' name=ID (imports+=Import)*  (statements+=Statement)* ;
	Import : 'import' importURI=STRING; // must be named importURI



/**
 * Statements (i.e. commands in the GAML descriptions).
 */ 
	Statement: (IfEval | ClassicStatement);
	ClassicStatement returns Statement: key=ID facets = Facets (block=Block | ';');
	IfEval returns Statement: key='if' facet= ConditionFacet block=Block (=>'else' else=(Statement | Block))?;

/**
 * Facets
 */ 
 
 	Facets : {Facets} first=FirstFacet (others+=Facet)*;
 	FirstFacet returns Facet: key= FacetKey? expr=Expression;
 	ConditionFacet returns Facet: key= 'condition:' ? expr = Expression;
	FacetKey: (ID ':') ;
	Facet:    (key= ('function:'|  '->') '{' expr=Expression '}') | (key='<-' expr=Expression) | (key=FacetKey expr=Expression);

/**
 * Blocks. An ordered list of statements inside curly brackets
 */ 
	Block: {Block} '{' (statements+=Statement)* '}';

/**
 * Expressions
 */ 
	Expression: TernExp;
	TernExp returns Expression: 
		OrExp 
			({TernExp.left=current} 				
				op='?' 
				right=OrExp 
				':' 
				ifFalse=OrExp
			)?
	; 
	OrExp returns Expression: 
		AndExp 
			({Expression.left=current} 				
				op='or' 
				right=AndExp
			)*
	;
	AndExp returns Expression: 
		Relational 
			({Expression.left = current} 			
				op='and' 
				right=Relational
			)*
	;
	Relational returns Expression: 
		PairExpr 
			(({Expression.left=current}				
				op=('!='|'='|'>='|'<='|'<'|'>')) 
				right=PairExpr
			)?
	;
	
	PairExpr returns Expression:  
		Addition 
			(({PairExpr.left= current}
				op='::'
			) 
			right=Addition)?
	;
	Addition returns Expression: 
		Multiplication 
		(({Expression.left=current}op=('+'|'-')) 
			right=Multiplication
		)*
	;
	Multiplication returns Expression: 
		GamlBinaryExpr 
		(({Expression.left=current}op=('*'|'/'|'^')) right=GamlBinaryExpr)*
	;
	GamlBinaryExpr returns Expression: GamlUnitExpr (({GamlBinaryExpr.left=current} op=ID) right=GamlUnitExpr)*;
	GamlUnitExpr returns Expression: GamlUnaryExpr (({GamlUnitExpr.left=current}op='#') right=GamlUnaryExpr)?;
	GamlUnaryExpr returns Expression: MemberRef | {GamlUnaryExpr} ({GamlUnaryExpr.left=current}op=('-'|'!'|'my'|'the'|'not') right=GamlUnaryExpr);
	MemberRef returns Expression : PrimaryExpression ({MemberRef.left=current} op='.' right=Variable)*;
	PrimaryExpression returns Expression: TerminalExpression | Variable | Function | '('Expression')' | '[' {Array}(exprs+=Expression (',' exprs+=Expression)*)? ']' | '{' {Point} (left=Expression op=',' right=Expression ) '}';
	Function: {Function}(op=ID '('args+=Expression (',' args+=Expression)*')') ;
	Variable: {Variable} name= ID;
	
/**
 * Terminals
 */ 

	TerminalExpression: {IntLiteral} value=INTEGER | {DoubleLiteral}  value=DOUBLE  | {ColorLiteral}   value=COLOR   | {StringLiteral}  value=STRING  | {BooleanLiteral} value=BOOLEAN ;
	terminal INTEGER : '0' | ('1'..'9' ('0'..'9')*);
	terminal BOOLEAN : 'true' | 'false';
	terminal ID :  ('a'..'z'|'A'..'Z'|'_'|'0'..'9')+ ('$' ('a'..'z'|'A'..'Z'|'_'|'0'..'9')+)? ;
	terminal COLOR: '#' ('0'..'9'|'A'..'F')+ ;
	terminal DOUBLE: '1'..'9' ('0'..'9')* ('.' '0'..'9'+)? (('E' | 'e') ('+' | '-')? '0'..'9'+)? | '0' ('.' '0'..'9'+)? (('E' | 'e') ('+' | '-')? '0'..'9'+)? ;
	terminal STRING : '"' ( '\\' ('b'|'t'|'n'|'f'|'r'|'u'|'"'|'\\') | !('\\'|'"') )* '"' | "'" ( '\\' ('b'|'t'|'n'|'f'|'r'|'u'|"'"|'\\') | !('\\'|"'") )* "'" ; 
	terminal ML_COMMENT	: '/*' -> '*/';
	terminal SL_COMMENT : '//' !('\n'|'\r')* ('\r'? '\n')?;
	terminal WS : (' '|'\t'|'\r'|'\n')+;
	terminal ANY_OTHER : .;
