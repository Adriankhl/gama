grammar msi.gama.lang.gaml.Gaml hidden(WS, ML_COMMENT, SL_COMMENT)

import "http://www.eclipse.org/emf/2002/Ecore" as ecore
generate gaml "http://www.gama.msi/lang/gaml/Gaml"

Model : 'model' name=ID (imports+=Import)* (('_gaml {{' gaml=GamlLangDef '}}')? (statements+=Statement)*) ;

Import :  'import' importURI=STRING;


/**
 * GamlLangDef: meta-grammar used to parse the tokens introduced automatically in the imports by GAMA
 */ 
GamlLangDef: ( k+=DefKeyword | b+=DefBinaryOp | r+=DefReserved | u+=DefUnit | unaries+=DefUnary )+;
DefKeyword: (('_keyword &'|'_definition &') name=ID'&;');
DefBinaryOp: '_binary &' name=ID'&;';
DefReserved: '_reserved &' name=ID'&;';
DefUnary: '_unary &'name=ID '&;';
DefUnit: '_unit &'name=ID'&;';

GamlKeywordRef: (ref=[DefKeyword]);
GamlBinarOpRef: ref=[DefBinaryOp];
GamlUnitRef: ref=[DefUnit];
GamlReservedRef: ref=[DefReserved];
GamlUnaryRef: ref=[DefUnary];
AbstractGamlRef: GamlKeywordRef | GamlBinarOpRef | GamlUnitRef | GamlReservedRef;

/**
 * Statement: both declarations, model sections and commands 
 */

//Statement: key=GamlKeywordRef ((=>name=ID | arg=Expression)? facets+=FacetExpr* (block=Block|';')) | ((=>name=ID | arg=Expression)? block=Block) ;
//Statement:key=GamlKeywordRef  ((=>name=ID | arg=Expression)? (facets+=FacetExpr)* ';') | =>WithBlock;
//
//WithBlock : 
//	 (=>block=Block | ((=>name=ID | arg=Expression)) block=Block | (=>name=ID | arg=Expression)? facets+=FacetExpr+  block=Block) ;


Statement: key=GamlKeywordRef arg=Expression? facets+=FacetExpr* (block=Block|';')
;

FacetExpr: key=FacetKey ':' expr=Expression;
	
FacetKey: ID;

Block:
	{Block} '{' (statements+=Statement)* '}';

VarDefinition: // for variable reference
	Statement | FacetExpr | DefUnit | DefReserved | DefUnary /*for types */;

Expression:
	TernExp;

TernExp returns Expression:
	OrExp ({Ternary.condition=current} '?' ifTrue=OrExp ':' ifFalse=OrExp)?; 

OrExp returns Expression:
	AndExp ({Or.left=current} 'or' right=AndExp)*;

AndExp returns Expression:
	Relational ({And.left=current} 'and' right=Relational)*;

Relational returns Expression:
	PairExpr
	(
		( {RelNotEq.left=current}'!='
		| {RelEq.left=current}   '='
		| {RelLtEq.left=current} '>='
		| {RelGtEq.left=current} '<='
		| {RelLt.left=current}   '<'
		| {RelGt.left=current}   '>' )
	right=PairExpr
	)?;

PairExpr returns Expression:
	Addition (({Pair.left=current}'::') right=Addition)?;

Addition returns Expression:
	Multiplication (({Plus.left=current}'+'|{Minus.left=current}'-') right=Multiplication)*;

Multiplication returns Expression:
	GamlBinExpr (({Multi.left=current}'*'|{Div.left=current}'/'|{Pow.left=current}'^') right=GamlBinExpr)*;

GamlBinExpr returns Expression:
	GamlUnitExpr (({GamlBinary.left=current} op=GamlBinarOpRef) right=GamlUnitExpr)*;

GamlUnitExpr returns Expression:
	GamlUnaryExpr (({Unit.left=current}'#') right=GamlUnitRef)?;

GamlUnaryExpr returns Expression:
	PrePrimaryExpr | 
	{GamlUnary} (op=UnarOp right=GamlUnaryExpr);
UnarOp:
	'-' |
	'!' |
	'my'  |
	'the' |
	'not' ;
// conflict between unary and binary
// see http://www.eclipse.org/forums/?t=msg&th=169692

PrePrimaryExpr returns Expression:
	TerminalExpression | RightMemberRef | MemberRef; 

MemberRef returns Expression:
	PrimaryExpression ({MemberRefP.left=current} '.' right=RightMemberRef)?;

PrimaryExpression returns Expression:
	'('Expression')' |
	'[' Array ']' |
	('#{' Point  '}');

Point:
	x=Expression ',' y=Expression;

Array: {Array}(exprs+=Expression (',' exprs+=Expression)*);
//	(rows+=Row (';' rows+=Row)*)?;
//Row:
//	exprs+=Expression (',' exprs+=Expression)*;

RightMemberRef returns Expression:
	AbstractRef ({MemberRefR.left=current} '.' right=RightMemberRef)?;

AbstractRef returns Expression:
	VariableRef
		(
			({FunctionRef.func=current} '('(args+=Expression (',' args+=Expression)*)?')' ) 
			| ({ArrayRef.array=current} '['(args+=Expression (',' args+=Expression)*)?']' )
		)?;

VariableRef:
	ref=[VarDefinition];

TerminalExpression:
	{IntLiteral}     value=INT     |
	{DoubleLiteral}  value=DOUBLE  |
	{ColorLiteral}   value=COLOR   |
	{StringLiteral}  value=STRING  |
	{BooleanLiteral} value=BOOLEAN ;

// -----
terminal INT returns ecore::EInt:	('0'..'9')+;

terminal BOOLEAN returns ecore::EBoolean: 'true' | 'false';

terminal ID :  ('a'..'z'|'A'..'Z'|'_'|'0'..'9')('a'..'z'|'A'..'Z'|'_'|'0'..'9')*;


terminal COLOR: '#' ('0'..'9'|'A'..'F')+ ;

// @see http://java.sun.com/javase/6/docs/api/java/lang/Double.html#valueOf(java.lang.String)
terminal DOUBLE:// returns ecore::EDouble : 
	'1'..'9' ('0'..'9')* ('.' '0'..'9'+)? (('E' | 'e') ('+' | '-')? '0'..'9'+)?
	| '0' ('.' '0'..'9'+)? (('E' | 'e') ('+' | '-')? '0'..'9'+)? ;

terminal STRING :
	'"' ( '\\' ('b'|'t'|'n'|'f'|'r'|'u'|'"'|'\\') | !('\\'|'"') )* '"' |
	"'" ( '\\' ('b'|'t'|'n'|'f'|'r'|'u'|"'"|'\\') | !('\\'|"'") )* "'" ; 


terminal ML_COMMENT	: '/*' -> '*/';

terminal SL_COMMENT : '//' !('\n'|'\r')* ('\r'? '\n')?;

terminal WS :	(' '|'\t'|'\r'|'\n')+;

terminal ANY_OTHER : .;
