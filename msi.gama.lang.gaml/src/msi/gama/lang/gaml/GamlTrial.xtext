grammar msi.gama.lang.gaml.Gaml hidden(WS, ML_COMMENT, SL_COMMENT)

import "http://www.eclipse.org/emf/2002/Ecore" as ecore
generate gaml "http://www.gama.msi/lang/gaml/Gaml"

Model:
	'model' name=ID
	(imports+=Import)*
	(gaml=GamlLangDef)?
	(statements+=Statement)*;

Import:
	'import'
	importURI=STRING; // feature must be named importURI
GamlLangDef:
	'_gaml' '{' (k+=DefKeyword | f+=DefFacet | b+=DefBinaryOp | r+=DefReserved | u+=DefUnit | unaries+=DefUnary)+ '}';

DefKeyword:
	('_keyword' | '_definition') name=ID (block=GamlBlock | ';');

GamlBlock:
	'{'
	{GamlBlock}
	('_facets' '[' facets+=[DefFacet] (',' facets+=[DefFacet])* ']')?
	('_children' '[' childs+=[DefKeyword] (',' childs+=[DefKeyword])* ']')?
	'}';

DefFacet:
	'_facet' name=ID (':' type=[DefReserved])? ('=' default=TerminalExpression)? ';';

DefBinaryOp:
	'_binary' name=ID ';';

DefReserved:
	'_reserved' name=ID (':' type=[DefReserved])? ('=' value=TerminalExpression)? ';';

DefUnary:
	'_unary' name=ID (':' type=[DefReserved])? ('=' value=TerminalExpression)? ';';

DefUnit:
	'_unit' name=ID ('=' coef=DOUBLE)? ';';

AbstractGamlRef: // for highlight
	GamlFacetRef | GamlKeywordRef | GamlBinarOpRef | GamlUnitRef | GamlReservedRef;

GamlKeywordRef: // for highlight
	ref=[DefKeyword];

GamlFacetRef hidden():
	ref=[DefFacet] ':';
GamlBinarOpRef:
	ref=[DefBinaryOp];
GamlUnitRef:
	ref=[DefUnit];
GamlReservedRef:
	ref=[DefReserved];
GamlUnaryRef:
	ref=[DefUnary];
	
Statement:
	SpecialStatement | Definition | Evaluation;
SpecialStatement:
	SetEval | LoopEval | ReturnEval | IfEval | DoEval | ItemEval | CreateEval | TargetEval;


IfEval:
	key='if' (facets+=FacetExpr)? expr=Expression block=Block;
ReturnEval:
	key='return' ('value:')? expr=Expression (block=Block | ';');
LoopEval:
	key='loop' ('var:')? (name=ID)? (facets+=FacetExpr)+ block=Block;
SetEval:
	key='set' ('var:')? var=Expression (facets+=FacetExpr) (block=Block | ';');
DoEval:
// Special rules to organize in the parser for "do", as facets can be arguments of the action
	key='do' ('action:')? name=ID (facets+=FacetExpr)* (block=Block | ';');
ItemEval:
	key=('add'|'remove'|'put'|'save') 'item:'? item=Expression (facets+=FacetExpr)+ (block=Block | ';');
CreateEval:
	key='create' 'species:'? species=Expression (facets+=FacetExpr)* (block=Block | ';');
TargetEval:
	key=('capture'|'release'|'ask') 'target:'? target=Expression (facets+=FacetExpr)+ (block=Block | ';');

Definition: // const/var/let/species/grid/gis/state/arg
	key=GamlKeywordRef name=ID (facets+=FacetExpr)* (block=Block | ';');

Evaluation:
	key=GamlKeywordRef /* (':' arg=Expression)? */(facets+=FacetExpr)* (block=Block | ';');

FacetExpr:
	ReturnsFacetExpr | NameFacetExpr | (key=GamlFacetRef expr=Expression);
ReturnsFacetExpr:
	'returns:' name=ID;
NameFacetExpr:
	'name:' name=ID;

Block:
	{Block} '{' (statements+=Statement)* '}';
AbstractDefinition: // for variable reference
	Definition | DefReserved | DefUnary | ReturnsFacetExpr | NameFacetExpr  | LoopEval;
Expression:
	TernExp;
TernExp returns Expression:
	OrExp ({Ternary.condition=current} '?' ifTrue=OrExp ':' ifFalse=OrExp)?;
OrExp returns Expression:
	AndExp ({Or.left=current} 'or' right=AndExp)*;
AndExp returns Expression:
	Relational ({And.left=current} 'and' right=Relational)*;
Relational returns Expression:
	PairExpr (({RelNotEq.left=current} '!=' | {RelEq.left=current} '=' | {RelLtEq.left=current} '>=' |
	{RelGtEq.left=current} '<=' | {RelLt.left=current} '<' | {RelGt.left=current} '>') right=PairExpr)?;
PairExpr returns Expression:
	Addition (({Pair.left=current} '::') right=Addition)?;
Addition returns Expression:
	Multiplication (({Plus.left=current} '+' | {Minus.left=current} '-') right=Multiplication)*;
Multiplication returns Expression:
	GamlBinExpr (({Multi.left=current} '*' | {Div.left=current} '/' | {Pow.left=current} '^') right=GamlBinExpr)*;
GamlBinExpr returns Expression:
	GamlUnitExpr (({GamlBinary.left=current} op=GamlBinarOpRef) right=GamlUnitExpr)*;
GamlUnitExpr returns Expression:
	GamlUnaryExpr (({Unit.left=current} '#') right=GamlUnitRef)?;
GamlUnaryExpr returns Expression:
	PrePrimaryExpr | {GamlUnary} (op=UnarOp right=GamlUnaryExpr);
UnarOp:
	'-' | '!' | 'my' | 'the' | 'not';
PrePrimaryExpr returns Expression:
	TerminalExpression | RightMemberRef | MemberRef;
MemberRef returns Expression:
	PrimaryExpression ({MemberRefP.left=current} '.' right=RightMemberRef)?;
PrimaryExpression returns Expression: 
	'(' Expression ')' | '[' Matrix ']' | '{' Point '}';
Point:
	x=Expression ',' y=Expression;
Matrix:
	{Matrix} (rows+=Row (';' rows+=Row)*)?;
Row:
	exprs+=Expression (',' exprs+=Expression)*;
RightMemberRef returns Expression:
	AbstractRef ({MemberRefR.left=current} '.' right=RightMemberRef)?;
AbstractRef returns Expression:
	VariableRef (({FunctionRef.func=current} '(' /*(*/args+=Expression /* (',' args+=Expression)*)?*/ ')') |
	({ArrayRef.array=current} '[' (args+=Expression (',' args+=Expression)*)? ']'))?;
VariableRef:
	ref=[AbstractDefinition];
TerminalExpression:
	{IntLiteral} value=INT | {DoubleLiteral} value=DOUBLE | {ColorLiteral} value=COLOR | {StringLiteral} value=STRING |
	{BooleanLiteral} value=BOOLEAN;
terminal INT returns ecore::EInt:
	'0' | ('1'..'9' ('0'..'9')*);
terminal BOOLEAN returns ecore::EBoolean:
	'true' | 'false';
terminal ID:
	('a'..'z' | 'A'..'Z' | '_' | '0'..'9')+ ('$' ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')+)?;
terminal COLOR:
	'#' ('0'..'9' | 'A'..'F')+;
terminal DOUBLE: // returns ecore::EDouble : 
	'1'..'9' ('0'..'9')* ('.' '0'..'9'+)? (('E' | 'e') ('+' | '-')? '0'..'9'+)?
	| '0' ('.' '0'..'9'+)? (('E' | 'e') ('+' | '-')? '0'..'9'+)?;
terminal STRING:
	'"' ('\\' ('b' | 't' | 'n' | 'f' | 'r' | 'u' | '"' | '\\') | !('\\' | '"'))* '"' |
	"'" ('\\' ('b' | 't' | 'n' | 'f' | 'r' | 'u' | "'" | '\\') | !('\\' | "'"))* "'";
terminal ML_COMMENT:
	'/*'->'*/';
terminal SL_COMMENT:
	'//' !('\n' | '\r')* ('\r'? '\n')?;
terminal WS:
	(' ' | '\t' | '\r' | '\n')+;
terminal ANY_OTHER:
	.;
