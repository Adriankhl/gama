grammar msi.gama.lang.gaml.Gaml hidden(WS, ML_COMMENT, SL_COMMENT)

import "http://www.eclipse.org/emf/2002/Ecore" as ecore
generate gaml "http://www.gama.msi/lang/gaml/Gaml"


Model:
	'model' name=ID (imports+=Import)* (statements+=Statement)* | {StringEvaluator} name=ID "<-" expr=Expression;

Import:
	'import' importURI=STRING; // must be named importURI
	

BuiltInStatementKey:
	//Statements that accept an expression as their "default" facet
	// FIXME : this is nonsense ! This list should not exist
	'add' |
	'ask' |
	'capture' |
	'create' |
	'draw' |
	'error'|
	'match' |
	'match_between' |
	'match_one' |
	'put' |
	'release' |
	'remove' |
	'save' |
	'set' |
	'switch'|
	'warn'|
	'write' |
	'display_population' |
	'display_grid' | 
	'using';

/**
 * Statements 
 */
Statement:
	=>AssignmentStatement | ( ReturnStatement | IfStatement  | ClassicStatement | DefinitionStatement  | Equation);

Equation returns Statement: function=Function key="=" expr=Expression ';';
 
IfStatement returns Statement:
	key='if' ('condition:')? expr=Expression block=Block (=> 'else' else=(IfStatement | Block))?;

ClassicStatement returns Statement:
	key=BuiltInStatementKey (ID':')? expr=Expression (facets+=Facet)* (block=Block | ';');

DefinitionStatement returns Statement:
	(key=ID) of=Contents? name=(ID | STRING | BuiltInStatementKey)? ('(' (args=ActionArguments |=> params=Parameters)?')')? (facets+=Facet)* (block=Block | ';');
	
	
Contents: ('<' type=ID (',' type2= ID)? '>');

ReturnStatement returns Statement:
	key='return' expr=Expression? ';';

AssignmentStatement returns Statement:
	expr= Expression key=("<-"|"<<"|">>"|"+="|"-=" | "++" | "--") value=Expression (facets+=Facet)*';';
	
Parameters: 
	 {Parameters} (params=ParameterList)? 
;
ActionArguments:
	args+=ArgumentDefinition (',' args+=ArgumentDefinition)*;

ArgumentDefinition:
		type=ID of=Contents? name=(ID|BuiltInStatementKey) ('<-' default=Expression)?
	;
	
ParameterList returns ExpressionList: exprs+=Parameter (',' exprs+=Parameter)*;
Parameter returns Expression: {Parameter} ((builtInFacetKey=DefinitionFacetKey) | (left=VariableRef ':')) right=Expression;


/**
 * Facets
 */


Facet:
	FunctionFacet | ClassicFacet;

DefinitionFacetKey: "name:" | "returns:" | "action:";
	

ClassicFacet returns Facet:
	=>((key=ID ':' | key='<-') expr=Expression) | ((key=DefinitionFacetKey) name=(ID | STRING | BuiltInStatementKey));

FunctionFacet returns Facet:
	(key='function:' | key='->') '{' expr=Expression '}';

/*
 * Definition facets (which are used for cross referencing variables)
 */
//DefinitionFacetKey: 'name:' | 'returns:';
//DefinitionFacet returns Facet:
//	(key=DefinitionFacetKey) name=(ID | STRING | BuiltInStatementKey);

/**
 * Blocks. An ordered list of statements inside curly brackets
 */
Block:
	{Block} 
	(
		=>('{'  (function=Expression) '}') | 
		('{' (statements+=Statement)* '}')
	);

	/**
 * Expressions
 */
Expression:
	TernExp;

TernExp returns Expression:
	OrExp
	({TernExp.left=current}
	op='?'
	right=OrExp
	':'
	ifFalse=OrExp)?;

OrExp returns Expression:
	AndExp
	({Expression.left=current}
	op='or'
	right=AndExp)*;

AndExp returns Expression:
	Relational
	({Expression.left=current}
	op='and'
	right=Relational)*;

Relational returns Expression:
	PairExpr
	(({Expression.left=current}
	op=('!=' | '=' | '>=' | '<=' | '<' | '>'))
	right=PairExpr)?;

ArgPairExpr returns PairExpr:
	{ArgPairExpr} (arg=(ID|BuiltInStatementKey) op='::' | arg=DefinitionFacetKey op=':') right=Addition;
	// arg = GamlVarRef serait plus intelligent, non ? 

PairExpr returns Expression:
	=> ArgPairExpr |
	Addition
	(({PairExpr.left=current}
	op='::')
	right=Addition)?;

Addition returns Expression:
	Multiplication
	(({Expression.left=current} op=('+' | '-'))
	right=Multiplication)*;

Multiplication returns Expression:
	GamlBinaryExpr 
	(({Expression.left=current} op=('*' | '/' | '^')) right=GamlBinaryExpr)*;

GamlBinaryExpr returns Expression:
	GamlUnitExpr
	(({GamlBinaryExpr.left=current} op=ID) right=GamlUnitExpr)*;

// NEW: Units can now be expressed using the "¡" symbol (in addition to "#")
GamlUnitExpr returns Expression:
	GamlUnaryExpr
	(({GamlUnitExpr.left=current} op=('#' | '¡')) right=UnitName)?;

GamlUnaryExpr returns Expression:
	Access |
	{GamlUnaryExpr} ({GamlUnaryExpr.left=current} (op='¡' right=UnitName) | (op=('-' | '!' | 'my' | 'the' | 'not')
	right=GamlUnaryExpr));
	
		
Access returns Expression:
	MemberRef (({Access.left=current} '[') args=ExpressionList ']')*;

MemberRef returns Expression:
	PrimaryExpression ({MemberRef.left=current} (op='.' right=PrimaryExpression))*;

PrimaryExpression returns Expression:
	TerminalExpression |
	VariableRef | 
	'(' Expression ')' | 
	'(' {Parameters} (params = ParameterList)? ')'|
	'[' {Array} exprs=ExpressionList? ']' | 
	'{' {Point} left=Expression op=',' right=Expression (',' z=Expression)? '}' |
	=>Function;

ExpressionList: exprs+=Expression (',' exprs+=Expression)*;

//AbstractRef returns Expression:
//	VariableRef | Function;

Function returns Expression :
	{Function} op=ID ('(' args = ExpressionList ')')?;






VariableRef returns Expression:
	{VariableRef} ref=[GamlVarRef];
	


UnitName returns Expression:
	{UnitName} op=ID;
	
GamlVarRef:
	ClassicFacet | DefinitionStatement ;

	/**
 * Terminals
 */
TerminalExpression:
	{IntLiteral} value=INTEGER | {DoubleLiteral} value=DOUBLE | {ColorLiteral} value=COLOR | {StringLiteral} value=STRING
	| {BooleanLiteral} value=BOOLEAN;

terminal INTEGER:
	'0' | ('1'..'9' ('0'..'9')*);

terminal BOOLEAN:
	'true' | 'false';

terminal ID:
	('a'..'z' | 'A'..'Z' | '_' | '$') ('a'..'z' | 'A'..'Z' | '_' | '$' | '0'..'9')*;
	
Fqn: ID ('.' ID)*;

terminal COLOR:
	'#' ('0'..'9' | 'A'..'F')+;

terminal DOUBLE:
	'1'..'9' ('0'..'9')* ('.' '0'..'9'+)? (('E' | 'e') ('+' | '-')? '0'..'9'+)? | '0' ('.' '0'..'9'+)? (('E' | 'e') ('+' |
	'-')? '0'..'9'+)?;

terminal STRING:
	'"' ('\\' ('b' | 't' | 'n' | 'f' | 'r' | 'u' | '"' | '\\') | !('\\' | '"'))* '"' | "'" ('\\' ('b' | 't' | 'n' | 'f' |
	'r' | 'u' | "'" | '\\') | !('\\' | "'"))* "'";

terminal ML_COMMENT:
	'/*'->'*/';

terminal SL_COMMENT:
	'//' !('\n' | '\r')* ('\r'? '\n')?;

terminal WS:
	(' ' | '\t' | '\r' | '\n')+;

terminal ANY_OTHER:
	.;
