grammar gama.core.lang.Gaml hidden(WS, ML_COMMENT, SL_COMMENT)

import "http://www.eclipse.org/emf/2002/Ecore" as ecore
generate gaml "http://gama/core/lang/Gaml"

Entry:
	-> Model | StringEvaluator | StandaloneBlock | ExperimentFileStructure;

StandaloneBlock:
	'__synthetic__' block=Block;

StringEvaluator:
	toto=ID "<-" expr=Expression;

Model:
	(pragmas+=Pragma)* 'model' name=ID (imports+=Import)* block=ModelBlock;

ModelBlock returns Block:
	{Block} (statements+=(S_Section))*;

Import:
	'import' importURI=STRING ("as" name=Valid_ID)?; // must be named importURI
Pragma:
	'@' name=ID;

	/**
 * Experiment files
 */
ExperimentFileStructure:
	exp=HeadlessExperiment;

HeadlessExperiment:
	key=_ExperimentKey name=(Valid_ID | STRING) ('model:' importURI=STRING)? (facets+=Facet)* (block=Block | ';');
	/**
 * Global statements
 */

// For a future release, drop the linking part ? Statements become simply: 
//T_Statement:
//	key=ID (expr=Expression)? (facets+=Facet)* (block=Block | ';') 
//;

 
S_Section returns Statement:
	S_Global | S_Species | S_Experiment;

S_Global:
	key="global" (facets+=Facet)* (block=Block | ';');

S_Species:
	key=_SpeciesKey name=ID (facets+=Facet)* (block=Block | ';');

S_Experiment:
	key=_ExperimentKey name=(Valid_ID | STRING) (facets+=Facet)* (block=Block | ';');

	/**
 * Statements
 */
Statement:
	(=> S_Declaration |
	((=> S_Assignment | S_1Expr_Facets_BlockOrEnd | S_Other | S_Do | S_Return | S_Solve | S_If | S_Try | S_Equations))) |
	S_Display;

S_1Expr_Facets_BlockOrEnd returns Statement:
	key=_1Expr_Facets_BlockOrEnd_Key (expr=Expression) (facets+=Facet)* (block=Block | ";");

S_Do:
	key=_DoKey expr=AbstractRef (facets+=Facet)* (block=Block | ';');

S_Loop:
	key="loop" (name=Valid_ID)? (facets+=Facet)* block=Block;

S_If:
	key='if' expr=Expression block=Block (-> 'else' else=(S_If | Block))?;

S_Try:
	key='try' block=Block (-> 'catch' catch=Block)?;

S_Other:
	key=ID (facets+=Facet)* (block=Block | ';');

S_Return:
	key='return' expr=Expression? ';';

	/*
 * DECLARATIONS
 */
S_Declaration:
	-> S_Definition | S_Species | S_Reflex | S_Action | S_Loop | S_StringDefinition;

S_Reflex:
	key=_ReflexKey (name=Valid_ID)? (facets+=Facet)* (block=Block | ';');

S_Definition:
	tkey=(TypeRef) name=Valid_ID ('(' (args=ActionArguments) ')')? (facets+=Facet)* (block=Block | ';');

S_StringDefinition:
	key=ID name=STRING (facets+=Facet)* (block=Block | ';');

S_Action returns S_Definition:
	{S_Action} key="action" name=Valid_ID ('(' (args=ActionArguments) ')')? (facets+=Facet)* (block=Block | ';');

	/*
 * ASSIGNMENTS
 */
S_Assignment:
	expr=Expression key=_AssignmentKey value=Expression (facets+=Facet)* ';';

S_Equations:
	key=_EquationsKey name=Valid_ID (facets+=Facet)* ('{' (equations+=S_Equation ';')* '}' | ';');

S_Equation returns S_Assignment:
	expr=(Function | VariableRef) key="=" value=Expression;

S_Solve:
	key=_SolveKey expr=EquationRef (facets+=Facet)* (block=Block | ';');

/**
 * DISPLAYS: to keep in order to distinguish species/grid from declarations
 */
S_Display:
	key="display" name=(Valid_ID | STRING) (facets+=Facet)* block=D_Block;

D_Block returns Block:
	{Block} '{' (statements+=D_Statement)* '}';

D_Statement returns Statement:
	D_Species | S_1Expr_Facets_BlockOrEnd;

D_Species:
	key=_SpeciesKey expr=Expression (facets+=Facet)* (block=D_Block | ";");

	/**
 * Statement keys
 */
_EquationsKey:
	"equation";

_SolveKey:
	"solve";

_SpeciesKey:
	"species" | "grid";

_ExperimentKey:
	"experiment";

_1Expr_Facets_BlockOrEnd_Key:
	_LayerKey | "ask" | "release" | "capture" | "create" | "write" | "error" | "warn" | "exception" | "save" | "assert" |
	"inspect" | "browse" |
	"draw" | "using" | "switch" | "put" | "add" | "remove" | "match" | "match_between" | "match_one" | "parameter" |
	"status" | "highlight" | "focus_on" | "layout";

_LayerKey:
	"light" | "camera" | "image" | "data" | "chart" | "agents" | "graphics"  | "event" | "overlay" | "datalist";

_DoKey:
	"do" | "invoke";

_ReflexKey:
	"init" | "reflex" | "aspect";

_AssignmentKey:
	"<-" | "<<" | '>' '>' | "<<+" | '>' '>-' | "+<-" | "<+" | ">-";

	/**
 * Parameters and arguments
 */
ActionArguments:
	args+=ArgumentDefinition (',' args+=ArgumentDefinition)*;

ArgumentDefinition:
	type=(TypeRef) name=Valid_ID ('<-' default=Expression)?;

	/**
 * Facets
 */
Facet:
	ActionFacet | DefinitionFacet | ClassicFacet  ;

ClassicFacetKey:
	(ID ':');

DefinitionFacetKey:
	"returns:";


SpecialFacetKey:
	'data:' | "init:" | "layout:" | 'image:' | "parameter:" | "aspect:" | "light:" | "as:" | "species:";

ActionFacetKey:
	"action:" | "on_change:";


ClassicFacet returns Facet:
	(key=ClassicFacetKey | key='<-' | key='->'| key=SpecialFacetKey) expr=Expression;

DefinitionFacet returns Facet:
	((-> key=DefinitionFacetKey) name=(Valid_ID | STRING));

ActionFacet returns Facet:
	key=ActionFacetKey (expr=ActionRef | block=Block);


	/**
 * Blocks. An ordered list of statements inside curly brackets
 */
Block:
	{Block} '{' ((statements+=Statement)* '}');

	/**
 * Expressions
 */
Expression:
	ArgumentPair | Pair;

BinaryOperator returns Expression:
	Or | And | Cast | Comparison | Addition | Multiplication | Exponentiation | Binary | Pair | Unit;

ArgumentPair:
	=> (op=(Valid_ID) '::' | op=(DefinitionFacetKey | SpecialFacetKey | ActionFacetKey ) ':')?
	right=Pair;

Pair returns Expression:
	If
	({BinaryOperator.left=current}
	op='::'
	right=If)?;

If returns Expression:
	Or
	({If.left=current}
	op='?'
	right=Or
	(':'
	ifFalse=Or))?;

Or returns Expression:
	And
	({BinaryOperator.left=current}
	op='or'
	right=And)*;

And returns Expression:
	Cast
	({BinaryOperator.left=current}
	op='and'
	right=Cast)*;

Cast returns Expression:
	Comparison
	(({BinaryOperator.left=current}
	op='as') ((right=TypeRef) | ('(' right=TypeRef ')')))?;

Comparison returns Expression:
	Addition
	(({BinaryOperator.left=current}
	op=('!=' | '=' | '>=' | '<=' | '<' | '>'))
	right=Addition)?;

Addition returns Expression:
	Multiplication
	(({BinaryOperator.left=current} op=('+' | '-'))
	right=Multiplication)*;

Multiplication returns Expression:
	Exponentiation
	(({BinaryOperator.left=current} op=('*' | '/')) right=Exponentiation)*;

Exponentiation returns Expression:
	Binary
	(({BinaryOperator.left=current} op=('^')) right=Binary)*;

Binary returns Expression:
	Unit
	(({BinaryOperator.left=current} op=(Valid_ID)) right=Unit)*;

Unit returns Expression:
	Unary
	(({Unit.left=current} op=("#")) right=UnitRef)?;

Unary returns Expression:
	Access |
	{Unary} ((op=('#') right=UnitRef) | (op=('-' | '!' | 'not') right=Unary));

Access returns Expression:
	Primary ({Access.left=current} ((op='[' right=ExpressionList? ']') | (op="." right=(AbstractRef | StringLiteral))))*;

Primary returns Expression:
	TerminalExpression |
	AbstractRef |
	'(' ExpressionList ')' |
	'[' {Array} exprs=ExpressionList? ']' |
	'{' {Point} left=Expression op=',' right=Expression (',' z=Expression)? '}';

AbstractRef returns Expression:
	=> Function | VariableRef;

Function returns Expression:
	{Function} (left=ActionRef) (type=TypeInfo)? '(' right=ExpressionList? ')';

ExpressionList:
		(exprs+=Expression (',' exprs+=Expression)*) | (exprs+=Parameter (',' exprs+=Parameter)*);

Parameter returns Expression:
	{Parameter} ((builtInFacetKey=(DefinitionFacetKey /*| TypeFacetKey*/ | SpecialFacetKey | ActionFacetKey )) |
	(left=VariableRef ':')) right=Expression;

UnitRef returns Expression:
	{UnitName} ref=[UnitFakeDefinition|ID];

VariableRef:
	{VariableRef} ref=[VarDefinition|Valid_ID];

TypeRef returns Expression:
	{TypeRef} (ref=[TypeDefinition|ID] parameter=TypeInfo?) | {TypeRef} ("species" parameter=TypeInfo);

TypeInfo:
	('<' first=TypeRef ("," second=TypeRef)? -> '>');

SkillRef returns Expression:
	{SkillRef} ref=[SkillFakeDefinition|ID];

ActionRef returns Expression:
	{ActionRef} ref=[ActionDefinition|Valid_ID];

EquationRef returns Expression:
	{EquationRef} ref=[EquationDefinition|Valid_ID];

GamlDefinition:
	TypeDefinition | VarDefinition | UnitFakeDefinition | SkillFakeDefinition | ActionDefinition | EquationDefinition | S_StringDefinition;

EquationDefinition:
	S_Equations | EquationFakeDefinition;

TypeDefinition:
	S_Species | TypeFakeDefinition;

VarDefinition:
	=> (S_Definition | S_Species | S_Reflex | S_Action | S_Loop) | (Model | ArgumentDefinition | DefinitionFacet | VarFakeDefinition | Import | S_Experiment);

ActionDefinition:
	S_Action | ActionFakeDefinition | S_Definition | TypeDefinition;

	// Fake Definitions produced by the global scope provider
UnitFakeDefinition:
	'**unit*' name=ID;

TypeFakeDefinition:
	'**type*' name=ID;

ActionFakeDefinition:
	'**action*' name=Valid_ID;

SkillFakeDefinition:
	'**skill*' name=ID;

VarFakeDefinition:
	'**var*' name=Valid_ID;

EquationFakeDefinition:
	'**equation*' name=Valid_ID;

Valid_ID:
	_SpeciesKey | _DoKey | _ReflexKey | _1Expr_Facets_BlockOrEnd_Key | _EquationsKey | ID |
	_ExperimentKey;

	/**
 * Terminals
 */
TerminalExpression:
	StringLiteral |
	{IntLiteral} op=INTEGER |
	{DoubleLiteral} op=DOUBLE |
	{BooleanLiteral} op=BOOLEAN |
	{ReservedLiteral} op=KEYWORD;

StringLiteral:
	op=STRING;

terminal KEYWORD:
	'each' | 'self' | 'myself' | 'nil' | 'super';

terminal INTEGER:
	'0' | ('1'..'9' ('0'..'9')*);

terminal BOOLEAN:
	'true' | 'false';

terminal ID:
	('a'..'z' | 'A'..'Z' | '_' | '$') ('a'..'z' | 'A'..'Z' | '_' | '$' | '0'..'9')*;

terminal DOUBLE:
	'1'..'9' ('0'..'9')* ('.' '0'..'9'+)? (('E' | 'e') ('+' | '-')? '0'..'9'+)? | '0' ('.' '0'..'9'+)? (('E' | 'e') ('+' |
	'-')? '0'..'9'+)?;

terminal STRING:
	'"' ('\\' ('b' | 't' | 'n' | 'f' | 'r' | 'u' | '"' | '\\') | !('\\' | '"'))* '"' | "'" ('\\' ('b' | 't' | 'n' | 'f' |
	'r' | 'u' | "'" | '\\') | !('\\' | "'"))* "'";

terminal ML_COMMENT:
	'/*'->'*/';

terminal SL_COMMENT:
	'//' !('\n' | '\r')* ('\r'? '\n')?;

terminal WS:
	(' ' | '\t' | '\r' | '\n')+;

terminal ANY_OTHER:
	.;
