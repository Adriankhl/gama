#summary Operators(Modeling Guide)



= <font color="blue"> Table of Contents </font> =

<wiki:toc max_depth="3" />

= <font color="blue"> Definition </font> =

An operator performs a function on one, two, or three operands. An operator that only requires one operand is called a unary operator. An operator that requires two operands is a binary operator. And finally, a ternary operator is one that requires three operands. The GAML programming language has only one ternary operator, ? :, which is a short-hand if-else statement.

Unary operators are written using aprefix parenthesized notation. Prefix notation means that the operator appears before its operand. Note that unary expressions should always been parenthesized:

{{{
unary_operator (operand)
}}}

Most of binary operators can use two notations:
  * the fonctional notation, which used a parenthesized notation around the operands (this notation cannot be used with arithmetic and relational operators such as: +, -, /, *, ^, =, !=, <, >, >=, <=... )
  * the infix notation, which means that the operator appears between its operands

{{{
binary_operator(op1, op2)

Or 

op1 binary_operator op2    
}}}

The ternary operator is also infix; each component of the operator appears between operands:

{{{
op1 ? op2 : op3
}}}

In addition to performing operations, operators are functional, i.e. they return a value. The return value and its type depend on the operator and the type of its operands. For example, the arithmetic operators, which perform basic arithmetic operations such as addition and subtraction, return numbers - the result of the arithmetic operation.

Moreover, operators are strictly functional, i.e. they have no side effects on their operands. For instance, the shuffle operator, which randomizes the positions of elements in a list, does not modify its list operand but returns a new shuffled list.

[#Table_of_Contents Top of the page]




= <font color="blue"> Operators by categories </font> =
 
== Cast ==
  * [#agent agent], [#as as], [#as_int as_int], [#as_matrix as_matrix], [#bool bool], [#container container], [#float float], [#geometry geometry], [#graph graph], [#int int], [#is is], [#map map], [#matrix matrix], [#pair pair], [#path path], [#point point], [#rgb rgb], [#species species], [#string string], [#to_gaml to_gaml], [#to_java to_java], [#topology topology], [#unknown unknown],  
== Colors ==
  * [#+ +],  
== Comparison ==
  * [#!= !=], [#< <], [#<= <=], [#= =], [#> >], [#>= >=],  
== Containers ==
  * [#:: ::], [#accumulate accumulate], [#among among], [#as_map as_map], [#collate collate], [#collect collect], [#contains_any contains_any], [#copy_between copy_between], [#count count], [#first_with first_with], [#grid_at grid_at], [#group_by group_by], [#in in], [#index_of index_of], [#inter inter], [#last_with last_with], [#max_of max_of], [#min_of min_of], [#of_generic_species of_generic_species], [#of_species of_species], [#remove_duplicates remove_duplicates], [#sort_by sort_by], [#where where], [#with_max_of with_max_of], [#with_min_of with_min_of],  
== Creation ==
  * [#around around], [#circle circle], [#cone cone], [#line line], [#link link], [#polygon polygon], [#rectangle rectangle], [#square square], [#triangle triangle],  
== Files ==
  * [#file file], [#folder folder], [#get get], [#image image], [#new_folder new_folder], [#properties properties], [#read read], [#shapefile shapefile], [#text text], [#write write],  
== GamaFileType ==
  * [#is_image is_image], [#is_properties is_properties], [#is_shape is_shape], [#is_text is_text],  
== Graphs ==
  * [#agent_from_geometry agent_from_geometry], [#as_distance_graph as_distance_graph], [#as_edge_graph as_edge_graph], [#as_intersection_graph as_intersection_graph], [#contains_edge contains_edge], [#contains_vertex contains_vertex], [#directed directed], [#in_edges_of in_edges_of], [#out_edges_of out_edges_of], [#predecessors_of predecessors_of], [#remove_node_from remove_node_from], [#rewire_n rewire_n], [#rewire_p rewire_p], [#set_verbose set_verbose], [#source_of source_of], [#successors_of successors_of], [#target_of target_of], [#undirected undirected], [#weight_of weight_of], [#with_optimizer_type with_optimizer_type], [#with_weights with_weights],  
== GraphsGraphstream ==
  * [#generate_barabasi_albert generate_barabasi_albert], [#generate_watts_strogatz generate_watts_strogatz], [#load_graph_from_dgs load_graph_from_dgs], [#load_graph_from_dgs_old load_graph_from_dgs_old], [#load_graph_from_dot load_graph_from_dot], [#load_graph_from_edge load_graph_from_edge], [#load_graph_from_gexf load_graph_from_gexf], [#load_graph_from_graphml load_graph_from_graphml], [#load_graph_from_lgl load_graph_from_lgl], [#load_graph_from_ncol load_graph_from_ncol], [#load_graph_from_pajek load_graph_from_pajek], [#load_graph_from_tlp load_graph_from_tlp],  
== IContainer ==
  * [#at at], [#empty empty], [#last last], [#list list], [#max max], [#min min], [#mul mul], [#sum sum],  
== IMatrix ==
  * [#column_at column_at], [#columns_list columns_list], [#row_at row_at], [#rows_list rows_list], [#times times],  
== Logic ==
  * [#: :], [#! !], [#? ?], [#and and], [#or or],  
== Maths ==
  * [#/ /], [#^ ^], [#abs abs], [#acos acos], [#asin asin], [#atan atan], [#ceil ceil], [#cos cos], [#div div], [#even even], [#exp exp], [#fact fact], [#floor floor], [#ln ln], [#mod mod], [#round round], [#sin sin], [#sqrt sqrt], [#tan tan], [#tanh tanh], [#with_precision with_precision],  
== Operators ==
  * [#- -], [#add_point add_point], [#masked_by masked_by], [#split_at split_at], [#union union],  
== Points ==
  * [#* *], [#<-> <->], [#norm norm],  
== Properties ==
  * [#crosses crosses], [#intersects intersects], [#overlaps overlaps], [#partially_overlaps partially_overlaps], [#touches touches],  
== Punctal ==
  * [#any_location_in any_location_in], [#closest_points_with closest_points_with], [#farthest_point_to farthest_point_to], [#points_at points_at],  
== Queries ==
  * [#agent_closest_to agent_closest_to], [#agents_at_distance agents_at_distance], [#agents_inside agents_inside], [#agents_overlapping agents_overlapping], [#at_distance at_distance], [#closest_to closest_to], [#inside inside], [#neighbours_at neighbours_at], [#neighbours_of neighbours_of], [#overlapping overlapping],  
== Random ==
  * [#binomial binomial], [#flip flip], [#gauss gauss], [#one_of one_of], [#poisson poisson], [#rnd rnd], [#shuffle shuffle], [#truncated_gauss truncated_gauss],  
== Relations ==
  * [#direction_between direction_between], [#distance_between distance_between], [#distance_to distance_to], [#path_between path_between], [#path_to path_to], [#towards towards],  
== Statistics ==
  * [#simple_clustering_by_distance simple_clustering_by_distance], [#simple_clustering_by_envelope_distance simple_clustering_by_envelope_distance],  
== Stats ==
  * [#frequency_of frequency_of], [#geometric_mean geometric_mean], [#harmonic_mean harmonic_mean], [#mean mean], [#mean_deviation mean_deviation], [#median median], [#standard_deviation standard_deviation], [#variance variance],  
== Strings ==
  * [#as_date as_date], [#as_time as_time], [#contains contains], [#contains_all contains_all], [#first first], [#is_number is_number], [#last_index_of last_index_of], [#length length], [#reverse reverse], [#split_with split_with],  
== System ==
  * [#. .], [#copy copy], [#dead dead], [#eval_gaml eval_gaml], [#eval_java eval_java], [#evaluate_with evaluate_with], [#every every], [#user_input user_input],  
== Transformations ==
  * [#as_4_grid as_4_grid], [#as_grid as_grid], [#at_location at_location], [#clean clean], [#convex_hull convex_hull], [#rotated_by rotated_by], [#simplification simplification], [#skeletonize skeletonize], [#split_lines split_lines], [#transformed_by transformed_by], [#translated_by translated_by], [#triangulate triangulate], [#without_holes without_holes], 

= <font color="blue"> Operators </font> =

    
== - == 

  * Possible use: 
    * OP(int) --->  int
    * OP(float) --->  float
    * shape OP shape --->  shape
    * shape OP list of shapes --->  shape
    * rgb OP rgb --->  rgb
    * point OP int --->  point
    * list OP list --->  list
    * rgb OP int --->  rgb
    * point OP point --->  point
    * int OP float --->  float
    * int OP int --->  int
    * point OP float --->  point
    * shape OP float --->  shape
    * list OP any --->  list
    * float OP int --->  float
    * matrix OP matrix --->  matrix
    * shape OP species --->  shape
    * float OP float --->  float
  * Result: a new color resulting from the substraction of the two operands, component by componentreturns a new list in which all the elements of the right operand have been removed from the left onea new color resulting from the substraction of each component of the color with the right operandthe difference of the two operands  
  * Comment: The behavior of the operator depends on the type of the operands.
  * Special cases:
    * if the right-operand is a point, a geometry or an agent, returns the geometry resulting from the difference between both geometries
    * if the right-operand is a list of points, geometries or agents, returns the geometry resulting from the difference between the left-geometry and all of the right-geometries
    * if the right operand is empty or nil, - returns the left operand
    * when it is used as an unary operator, - returns the opposite or the operand.
    * if both operands are points, returns their difference.
    * if both operands are numbers, performs a normal arithmetic difference and returns a float if one of them is a float.
    * if left-hand operand is a point and the right-hand a number, returns a new point with each coordinate as the difference of the operand coordinate with this number.
    * if the left-hand operand is a geometry and the rigth-hand operand a float, returns a geometry corresponding to the left-hand operand (geometry, agent, point) reduced by the right-hand operand distance
    * if the right operand is an object of any type (except list), - returns a copie of the left operand without this object
    * if the right-operand is a species, returns the geometry resulting from the difference between the left-geometry and all of geometries all agents of the right-species    
  * See also: [#+ +], 
  {{{  
     geom1 - geom2 -> a geometry corresponding to difference between geom1 and geom2
     geom1 - [geom2, geom3, geom4] -> a geometry corresponding to geom1 - (geom2 + geom3 + geom4)
     rgb([255, 128, 32]) - rgb('red')   	:--  	rgb([0,128,32])
     {1, 2} - 4 	--:	 {-3.0;-2.0}
     [1,2,3,4,5,6] - [2,4,9] 	--: 	[1,3,5,6]
     [1,2,3,4,5,6] - [0,8] 		--:	 	[1,2,3,4,5,6]
     rgb([255, 128, 32]) - 3 	:--  	rgb([252,125,29])
     - (-56) 	--:	 56
     {1, 2} - {4, 5} 	--:	 {-3.0;-3.0}
     1 - 1 	--:	 0
     {1, 2} - 4.5 	--:	 {-3.5, -2.5}
     shape - 5 -> returns a geometry corresponding to the geometry of the agent applying the operator reduced by a distance of 5
     [1,2,3,4,5,6] - 2 		--: 	[1,3,4,5,6]
     [1,2,3,4,5,6] - 0 		--:	 	[1,2,3,4,5,6]
     1.0 - 1 → 0.0
     geom1 - speciesA -> a geometry corresponding to geom1 - (the geometry of all agents of species speciesA)
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== : == 

  * Possible use: 
    * any OP any --->  any
  * Result:     
  * See also: [#? ?], 
[#Table_of_Contents Top of the page] 
  	
    
== :: == 

  * Possible use: 
    * any OP any --->  pair
  * Result: produces a new pair combining the left and the right operands
[#Table_of_Contents Top of the page] 
  	
    
== ! == 

  * Possible use: 
    * OP(bool) --->  bool
  * Result: opposite boolean value.
  * Special cases:
    * if the parameter is not boolean, it is casted to a boolean value.    
  * See also: [#bool bool], 
  {{{  
     ! (true) 		--:	 	false
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== != == 

  * Possible use: 
    * int OP int --->  bool
    * float OP int --->  bool
    * int OP float --->  bool
    * any OP any --->  bool
    * float OP float --->  bool
  * Result: true if both operands are different, false otherwise  
  * Comment:  this operator will return false if the two operands are identical (i.e., the same object) or equal. Comparisons between nil values are permitted.    
  * See also: [#= =], 
  {{{  
     3 != 3    	--: false
     [2,3] != [2,3] --: false
     [2,4] != [2,3] --: true
     4.5 = 4.7  	--:  false
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== ? == 

  * Possible use: 
    * bool OP any expression --->  any
  * Result: if the left-hand operand evaluates to true, returns the value of the left-hand operand of the :, otherwise that of the right-hand operand of the :  
  * Comment: These functional tests can be combined together.    
  * See also: [#: :], 
  {{{  
     [10, 19, 43, 12, 7, 22] collect ((each > 20) ? 'above' : 'below')    --:  ['below', 'below', 'above', 'below', 'below', 'above']
     set color value:(food > 5) ? 'red' : ((food >= 2)? 'blue' : 'green');
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== / == 

  * Possible use: 
    * float OP int --->  float
    * float OP float --->  float
    * int OP float --->  float
    * int OP int --->  float
    * rgb OP int --->  rgb
    * point OP int --->  point
    * rgb OP float --->  rgb
    * point OP float --->  point
  * Result: a float, equal to the division of the left-hand operand by the rigth-hand operand.a new color resulting from the division of each component of the color by the right operanda new color resulting from the division of each component of the color by the right operand. The result on each component is then truncated.
  * Special cases:
    * if the right-hand operand is equal to zero, raises a "Division by zero" exception
    * if the left-hand operator is a point and the right-hand a number, returns a point with coordinates divided by the number    
  * See also: [#* *], 
  {{{  
     
     
     rgb([255, 128, 32]) / 2 	:--  	rgb([127,64,16])
     {2,5} / 4	--:  {0.5;1.25}
     rgb([255, 128, 32]) / 2.5 	:--  	rgb([102,51,13])
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== . == 

  * Possible use: 
    * agent OP any expression --->  any
  * Result: returns an evaluation of the expresion (right-hand operand) in the scope the given agent.
  * Special cases:
    * if the agent is nil or dead, throws an exception
  {{{  
     agent.location 		--: 	returns the location of the agent
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== ^ == 

  * Possible use: 
    * int OP int --->  int
    * float OP float --->  float
    * int OP float --->  float
    * float OP int --->  float
  * Result: the left-hand operand raised to the power of the right-hand operand.
  * Special cases:
    * if the right-hand operand is equal to 0, returns 1
    * if it is equal to 1, returns the left-hand operand.    
  * See also: [#* *], [#sqrt sqrt], 
  {{{  
     
     
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== * == 

  * Possible use: 
    * point OP int --->  point
    * point OP float --->  point
    * float OP float --->  float
    * rgb OP int --->  rgb
    * int OP int --->  int
    * point OP point --->  float
    * int OP float --->  float
    * float OP int --->  float
    * shape OP float --->  shape
  * Result: a new color resulting from the product of each component of the color with the right operandthe product of the two operands
  * Special cases:
    * if the left-hand operator is a point and the right-hand a number, returns a point with coordinates multiplied by the number
    * if both operands are int, returns the product as an int
    * if both operands are points, returns their scalar product
    * if the left-hand operand is a geometry and the rigth-hand operand a float, returns a geometry corresponding to the left-hand operand (geometry, agent, point) scaled by the right-hand operand coefficient    
  * See also: [#/ /], 
  {{{  
     {2,5} * 4 	--: {8.0; 20.0}
     rgb([255, 128, 32]) * 2 	:--  	rgb([255,255,64])
     
     {2,5} * {4.5, 5} 	--:  34.0
     
     shape * 2 -> returns a geometry corresponding to the geometry of the agent applying the operator scaled by a coefficient of 2
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== + == 

  * Possible use: 
    * rgb OP int --->  rgb
    * shape OP map --->  shape
    * list OP list --->  list
    * point OP int --->  point
    * list OP any --->  list
    * matrix OP matrix --->  matrix
    * string OP any --->  string
    * shape OP float --->  shape
    * int OP int --->  int
    * string OP string --->  string
    * float OP int --->  float
    * point OP float --->  point
    * int OP float --->  float
    * float OP float --->  float
    * point OP point --->  point
    * rgb OP rgb --->  rgb
    * shape OP shape --->  shape
  * Result: a new color resulting from the sum of each component of the color with the right operandreturns a new list containing all the elements of both operandsthe sum, union or concatenation of the two operands.a new color resulting from the sum of the two operands, component by component  
  * Comment: + is only defined with a list as left operand
  * Special cases:
    * if the left-hand operand is a geometry and the rigth-hand operand a map (with [distance::float, quadrantSegments:: int (the number of line segments used to represent a quadrant of a circle), endCapStyle::int (1: (default) a semi-circle, 2: a straight line perpendicular to the end segment, 3: a half-square)]), returns a geometry corresponding to the left-hand operand (geometry, agent, point) enlarged considering the right-hand operand parameters
    * if the right operand is nil, + returns the left operand
    * if the right operand is an object of any type (except list), + returns a copie of the left operand with this object
    * if the left-hand operand is a geometry and the rigth-hand operand a float, returns a geometry corresponding to the left-hand operand (geometry, agent, point) enlarged by the right-hand operand distance
    * if both operands are numbers (float or int), performs a normal arithmetic sum and returns a float if one of them is a float.
    * if the left-hand operand is a string, returns the concatenation of the two operands (the left-hand one beind casted into a string
    * if left-hand operand is a point and the right-hand a number, returns a new point with each coordinate as the sum of the operand coordinate with this number.
    * if both operands are points, returns their sum.
    * if the right-operand is a point, a geometry or an agent, returns the geometry resulting from the union between both geometries    
  * See also: [#- -], [#- -], 
  {{{  
     rgb([255, 128, 32]) + 3 	:--  	rgb([255,131,35])
     shape + [distance::5.0, quadrantSegments::4, endCapStyle:: 2] -> returns a geometry corresponding to the geometry of the agent applying the operator enlarged by a distance of 5, with 4 segments to represent a quadrant of a circle and a straight line perpendicular to the end segment
     [1,2,3,4,5,6] + [2,4,9] 	--: 	[1,2,3,4,5,6,2,4,9]
     [1,2,3,4,5,6] + [0,8] 		--: 	[1,2,3,4,5,6,0,8]
     {1, 2} + 4 	--:	 {5.0;6.0}
     [1,2,3,4,5,6] + 2 		--: 	[1,2,3,4,5,6,2]
     [1,2,3,4,5,6] + 0 		--:	 	[1,2,3,4,5,6,0]
     "hello " + 12 	--: 	"hello 12"
     shape + 5 -> returns a geometry corresponding to the geometry of the agent applying the operator enlarged by a distance of 5
     1 + 1 	--:	 2
     1.0 + 1 → 2.0
     {1, 2} + 4.5 	--:	 {5.5, 6.5}
     {1, 2} + {4, 5} 	--:	 {5.0;7.0}
     rgb([255, 128, 32]) + rgb('red') 	:--  	rgb([255,128,32])
     geom1 + geom2 -> a geometry corresponding to union between geom1 and geom2
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== < == 

  * Possible use: 
    * int OP float --->  bool
    * string OP string --->  bool
    * float OP int --->  bool
    * point OP point --->  bool
    * float OP float --->  bool
    * int OP int --->  bool
  * Result: true if the left-hand operand is less than the right-hand operand, false otherwise.
  * Special cases:
    * if the operands are strings, a lexicographic comparison is performed
    * if both operands are points, returns true if only if left component (x) of the left operand if less than or equal to x of the right one and if the right component (y) of the left operand is greater than or equal to y of the right one.
    * if one of the operands is nil, returns false
  {{{  
     3 < 2.5  --: false
     abc < aeb  --: true
     3.5 < 7  --: true
     {5,7} < {4,6}  --: false
     {5,7} < {4,8}  --: false
     3.5 < 7.6  --: true
     3 < 7  --:  true
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== <= == 

  * Possible use: 
    * string OP string --->  bool
    * point OP point --->  bool
    * int OP int --->  bool
    * int OP float --->  bool
    * float OP int --->  bool
    * float OP float --->  bool
  * Result: true if the left-hand operand is less or equal than the right-hand operand, false otherwise.
  * Special cases:
    * if the operands are strings, a lexicographic comparison is performed
    * if both operands are points, returns true if only if left component (x) of the left operand if less than or equal to x of the right one and if the right component (y) of the left operand is greater than or equal to y of the right one.
    * if one of the operands is nil, returns false
  {{{  
     abc <= aeb  --: true
     {5,7} <= {4,6}  --: false
     {5,7} <= {4,8}  --: false
     3 <= 7  --:  true
     3 <= 2.5  --: false
     7.0 <= 7  --: true
     3.5 <= 3.5  --: true
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== <-> == 

  * Possible use: 
    * int OP int --->  point
    * float OP float --->  point
    * int OP float --->  point
    * float OP int --->  point
    * shape OP shape --->  bool
  * Result: A boolean, equal to true if the left-geometry (or agent/point) is disjoints from the right-geometry (or agent/point).
  * Special cases:
    * if one of the operand is null, returns true.
    * if one operand is a point, returns false if the point is included in the geometry.    
  * See also: [#intersects intersects], [#crosses crosses], [#overlaps overlaps], [#partially_overlaps partially_overlaps], [#touches touches], 
  {{{  
     polyline([{10,10},{20,20}]) disjoint_from polyline([{15,15},{25,25}]) -> false.
     polygon([{10,10},{10,20},{20,20},{20,10}]) disjoint_from polygon([{15,15},{15,25},{25,25},{25,15}]) -> false.
     polygon([{10,10},{10,20},{20,20},{20,10}]) disjoint_from geometry({15,15}) -> false.
     polygon([{10,10},{10,20},{20,20},{20,10}]) disjoint_from geometry({25,25}) -> true.
     polygon([{10,10},{10,20},{20,20},{20,10}]) disjoint_from polygon([{35,35},{35,45},{45,45},{45,35}]) -> true
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== = == 

  * Possible use: 
    * float OP float --->  bool
    * any OP any --->  bool
  * Result: true if both operands are equal, false otherwise  
  * Comment: this operator will return true if the two operands are identical (i.e., the same object) or equal. Comparisons between nil values are permitted.    
  * See also: [#!= !=], 
  {{{  
     3 = 3    	--: true
     4.5 = 4.7  	--:  false
     3.0 = 3  	--:  true
     [2,3] = [2,3] --: true
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== > == 

  * Possible use: 
    * point OP point --->  bool
    * int OP float --->  bool
    * string OP string --->  bool
    * float OP int --->  bool
    * float OP float --->  bool
    * int OP int --->  bool
  * Result: true if the left-hand operand is greater than the right-hand operand, false otherwise.
  * Special cases:
    * if both operands are points, returns true if only if left component (x) of the left operand if greater than x of the right one and if the right component (y) of the left operand is greater than y of the right one.
    * if the operands are strings, a lexicographic comparison is performed
    * if one of the operands is nil, returns false
  {{{  
     {5,7} > {4,6}  --: true
     {5,7} > {4,8}  --: false
     3 > 2.5  --: true
     abc > aeb  --: false
     3.5 > 7  --: false
     3.5 > 7.6  --: false
     3 > 7  --:  false
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== >= == 

  * Possible use: 
    * int OP int --->  bool
    * string OP string --->  bool
    * float OP float --->  bool
    * float OP int --->  bool
    * int OP float --->  bool
    * point OP point --->  bool
  * Result: true if the left-hand operand is greater or equal than the right-hand operand, false otherwise.
  * Special cases:
    * if one of the operands is nil, returns false
    * if the operands are strings, a lexicographic comparison is performed
    * if both operands are points, returns true if only if left component (x) of the left operand if greater than or equal to x of the right one and if the right component (y) of the left operand is greater than or equal to y of the right one.
  {{{  
     3 >= 7  --:  false
     abc >= aeb  --: false
     abc >= abc  --: true
     3.5 >= 3.5  --: true
     3.5 >= 7  --: false
     3 >= 2.5  --: true
     {5,7} >= {4,6}  --: true
     {5,7} >= {4,8}  --: false
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== abs == 

  * Possible use: 
    * OP(float) --->  float
    * OP(int) --->  int
  * Result: the absolute value of the operand (so a positive int or float depending on the type of the operand).
  {{{  
     abs (200 * -1 + 0.5) → 200.5
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== accumulate == 

  * Possible use: 
    * container OP any expression --->  list
  * Result: returns a new flat list, in which each element is the evaluation of the right-hand operand. If this evaluation returns a list, the elements of this result are added directly to the list returned  
  * Comment: accumulate is dedicated to the application of a same computation on each element of a container (and returns a list) In the right-hand operand, the keyword each can be used to represent, in turn, each of the right-hand operand elements. 
  * Special cases:
    * if the left-hand operand is nil, accumulate returns an empty list    
  * See also: [#collect collect], 
  {{{  
     [a1,a2,a3] accumulate (each neighbours_at 10)  		--: 	a flat list of all the neighbours of these three agents
     [1,2,4] accumulate ([2,4])  		--: 	[2,4,2,4,2,4]
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== acos == 

  * Possible use: 
    * OP(float) --->  float
    * OP(int) --->  float
  * Result: the arccos of the operand (which has to be expressed in decimal degrees).    
  * See also: [#asin asin], [#atan atan], 
  {{{  
     acos (90) → 0
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== add_point == 

  * Possible use: 
    * shape OP point --->  shape
  * Result: A geometry resulting from the adding of a right-point (coordinate) to the right-geometry
  {{{  
     square(5) add_point {10,10} -> returns a hexagon
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== agent == 

  * Possible use: 
    * OP(any) --->  agent
  * Result: casting of the operand to an agent (if a species name is used, casting to an instance of species name).
  * Special cases:
    * if the operand is a point, returns the closest agent (resp. closest instance of species name) to that point (computed in the topology of the calling agent);
    * if the operand is an agent, returns the agent (resp. tries to cast this agent to species name and returns nil if the agent is instance of another species);
    * if the operand is an int, returns the agent (resp. instance of species name) with this unique index;    
  * See also: [#of_species of_species], [#species species], 
  {{{  
     species node {}
     node(0) 			--: node0
     node(3.78) 		--: null
     node(true) 		--: null
     node({23, 4.0} 	--: node2
     node(5::34) 		--: null
     node(green) 		--: null
     node([1,5,9,3]) 	--: null
     node(node1)		--: node1
     node('4')			--: null
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== agent_closest_to == 

  * Possible use: 
    * OP(any) --->  agent
  * Result: A agent, the closest to the operand (casted as a geometry).  
  * Comment: the distance is computed in the topology of the calling agent (the agent in which this operator is used), with the distance algorithm specific to the topology.    
  * See also: [#neighbours_at neighbours_at], [#neighbours_of neighbours_of], [#agents_inside agents_inside], [#agents_overlapping agents_overlapping], [#closest_to closest_to], [#inside inside], [#overlapping overlapping], 
  {{{  
     agent_closest_to(self) -> return the closest agent to the agent applying the operator.
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== agent_from_geometry == 

  * Possible use: 
    * path OP shape --->  agent
  * Result: returns the agent corresponding to given geometry (right-hand operand) in the given path (left-hand operand).
  * Special cases:
    * if the left-hand operand is nil, returns nil
  {{{  
     let line type: geometry <- one_of(path_followed.segments);
     let ag type: road <- road(path_followed agent_from_geometry line);
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== agents_at_distance == 

  * Possible use: 
    * OP(float) --->  list
  * Result: A list of agents situated at a distance <= the right argument.  
  * Comment: Equivalent to neighbours_at with a left-hand argument equal to 'self'    
  * See also: [#neighbours_at neighbours_at], [#neighbours_of neighbours_of], [#agent_closest_to agent_closest_to], [#agents_inside agents_inside], [#closest_to closest_to], [#inside inside], [#overlapping overlapping], [#at_distance at_distance], 
  {{{  
     agents_at_distance(20) -> all the agents (excluding the caller) which distance to the caller is <= 20
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== agents_inside == 

  * Possible use: 
    * OP(any) --->  list of agents
  * Result: A list of agents covered by the operand (casted as a geometry).    
  * See also: [#agent_closest_to agent_closest_to], [#agents_overlapping agents_overlapping], [#closest_to closest_to], [#inside inside], [#overlapping overlapping], 
  {{{  
     agents_inside(self) -> return the agents that are covered by the shape of the agent applying the operator.
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== agents_overlapping == 

  * Possible use: 
    * OP(any) --->  list of agents
  * Result: A list of agents overlapping the operand (casted as a geometry).    
  * See also: [#neighbours_at neighbours_at], [#neighbours_of neighbours_of], [#agent_closest_to agent_closest_to], [#agents_inside agents_inside], [#closest_to closest_to], [#inside inside], [#overlapping overlapping], [#at_distance at_distance], 
  {{{  
     agents_overlapping(self) -> return the agents that overlap the shape of the agent applying the operator.
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== among == 

  * Possible use: 
    * int OP container --->  list
    * int OP map --->  map
  * Result: a list of length the value of the left-hand operand, containing random elements from the right-hand operand
  * Special cases:
    * if the right-hand operand is empty or nil, among returns a new empty list
    * if the left-hand operand is greater than the length of the right-hand operand, among returns the right-hand operand.
    * if the right-hand operand is a map, among returns a map of right-hand operand element instead of a list
  {{{  
     3 among [1,2,4,3,5,7,6,8] 		--: 	[1,2,8]
     3 among g2 					--: 	[node6,node11,node7]
     3 among list(node)    			--:  	[node1,node11,node4]
     2 among [1::2, 3::4, 5::6] 	--: 	[1::2, 3::4]
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== and == 

  * Possible use: 
    * bool OP any expression --->  bool
  * Result: a bool value, equal to the logical and between the left-hand operand and the rigth-hand operand.  
  * Comment: both operands are always casted to bool before applying the operator. Thus, an expression like (1 and 0) is accepted and returns false.    
  * See also: [#bool bool], [#or or], 
[#Table_of_Contents Top of the page] 
  	
    
== any_location_in == 

  * Possible use: 
    * OP(shape) --->  point
  * Result: A point inside (or touching) the operand-geometry.    
  * See also: [#closest_points_with closest_points_with], [#farthest_point_to farthest_point_to], [#points_at points_at], 
  {{{  
     any_location_in(square(5)) -> a point of the square, for example : {3,4.6}.
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== around == 

  * Possible use: 
    * float OP any --->  shape
  * Result: A geometry resulting from the difference between a buffer around the right-operand casted in geometry at a distance left-operand (right-operand buffer left-operand) and the right-operand casted as geometry.
  * Special cases:
    * returns a circle geometry of radius right-operand if the left-operand is nil    
  * See also: [#circle circle], [#cone cone], [#line line], [#link link], [#norm norm], [#point point], [#polygon polygon], [#polyline polyline], [#rectangle rectangle], [#square square], [#triangle triangle], 
  {{{  
     10 around circle(5) -> returns a the ring geometry between 5 and 10.
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== as == 

  * Possible use: 
    * any OP species --->  agent
  * Result: casting of the left-hand operand to a species.
  * Special cases:
    * if the right-hand operand is nil, transforms the left-hand operand into an agent
    * if the left-hand operand is nil, returns nil
    * if the left-hand operand is an agent, if the right-hand is a agent, returns it, otherwise returns nil
    * if the left-oprand is a integer, returns an agent with the right-operans as id
    * if the left-operand is a poiny, returns the agent the closest to right-hand operand
    * otherwise, returns nil    
  * See also: [#agent agent], 
[#Table_of_Contents Top of the page] 
  	
    
== as_4_grid == 

  * Possible use: 
    * shape OP point --->  matrix
  * Result: A matrix of square geometries (grid with 4-neighbourhood) with dimension given by the rigth-hand operand ({nb_cols, nb_lines}) corresponding to the square tessellation of the left-hand operand geometry (geometry, agent)
  {{{  
     self as_grid {10, 5} -> returns matrix of square geometries (grid with 4-neighbourhood) with 10 columns and 5 lines corresponding to the square tessellation of the geometry of the agent applying the operator.
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== as_date == 

  * Possible use: 
    * OP(double) --->  string
    * double OP string --->  string
  * Result: converts a number into a string with year, month, day, hour, minutes, second following a given pattern (right-hand operand)  
  * Comment: Pattern should include : "%Y %M %D %h %m %s" for outputting years, months, days, hours, minutes, seconds
  * Special cases:
    * used as an unary operator, uses a defined pattern with years, months, days    
  * See also: [#as_time as_time], 
  {{{  
     22324234 as_date "%M m %D d %h h %m m %s seconds" 	--: 8 m 18 d 9 h 10 m 34 seconds
     as_date(22324234) 	--: 8 months, 18 days
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== as_distance_graph == 

  * Possible use: 
    * container OP float --->  graph
  * Result: creates a graph from a list of vertices (left-hand operand). An edge is created between each pair of vertices close enough (less than a distance, right-hand operand).  
  * Comment: as_distance_graph is more efficient for a list of points than as_intersection_graph.    
  * See also: [#as_intersection_graph as_intersection_graph], [#as_edge_graph as_edge_graph], 
  {{{  
     list(ant) as_distance_graph 3.0;
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== as_edge_graph == 

  * Possible use: 
    * OP(container) --->  graph
    * OP(map) --->  graph
  * Result: creates a graph from the list/map of edges given as operand
  * Special cases:
    * if the operand is a list, the graph will be built with elements of the list as vertices
    * if the operand is a map, the graph will be built by creating edges from pairs of the map    
  * See also: [# as_intersection_graph, as_distance_graph  as_intersection_graph, as_distance_graph], 
  {{{  
     as_edge_graph([{1,5},{12,45},{34,56}])  --:  build a graph with these three vertices and reflexive links on each vertices
     as_edge_graph([{1,5}::{12,45},{12,45}::{34,56}])  --:  build a graph with these three vertices and two edges
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== as_grid == 

  * Possible use: 
    * shape OP point --->  matrix
  * Result: A matrix of square geometries (grid with 8-neighbourhood) with dimension given by the rigth-hand operand ({nb_cols, nb_lines}) corresponding to the square tessellation of the left-hand operand geometry (geometry, agent)
  {{{  
     self as_grid {10, 5} -> returns a matrix of square geometries (grid with 8-neighbourhood) with 10 columns and 5 lines corresponding to the square tessellation of the geometry of the agent applying the operator.
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== as_int == 

  * Possible use: 
    * string OP int --->  int
  * Result: parses the string argument as a signed integer in the radix specified by the second argument.
  * Special cases:
    * if the left operand is nil or empty, as_int returns 0
    * if the left operand does not represent an integer in the specified radix, as_int throws an exception     
  * See also: [#int int], 
  {{{  
     '20' as_int 10 	--: 20;
     '20' as_int 8 		--: 16;
     '20' as_int 16 	--: 32
     '1F' as_int 16		--: 31
     'hello' as_int 32 	--: 18306744
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== as_intersection_graph == 

  * Possible use: 
    * container OP float --->  graph
  * Result: creates a graph from a list of vertices (left-hand operand). An edge is created between each pair of vertices with an intersection (with a given tolerance).  
  * Comment: as_intersection_graph is more efficient for a list of geometries (but less accurate) than as_distance_graph.    
  * See also: [#as_distance_graph as_distance_graph], [#as_edge_graph as_edge_graph], 
  {{{  
     list(ant) as_intersection_graph 0.5;
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== as_map == 

  * Possible use: 
    * container OP any expression --->  map
  * Result: produces a new map from the evaluation of the right-hand operand for each element of the left-hand operand  
  * Comment: the right-hand operand should be pair or a map.
  * Special cases:
    * if the left-hand operand is nil or empty, as_map returns a new empty map.
  {{{  
     [1,2,3,4,5,6,7,8] as_map (each::(each * 2) 	--: 	[1::2, 2::4, 3::6, 4::8, 5::10, 6::12, 7::14, 8::16]
     [1::2,3::4,5::6] as_map (each::(each * 2))		--: 	[2::4, 4::8, 6::12] 
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== as_matrix == 

  * Possible use: 
    * any OP point --->  matrix
    * container OP point --->  matrix
  * Result: casts the left operand into a matrix with right operand as preferrenced size  
  * Comment: This operator is very useful to cast a file containing raster data into a matrix.Note that both components of the right operand point should be positive, otherwise an exception is raised.The operator as_matrix creates a matrix of preferred size. It fills in it with elements of the left operand until the matrix is full If the size is to short, some elements will be omitted. Matrix remaining elements will be filled in by nil.
  * Special cases:
    * if the right operand is nil, as_matrix is equivalent to the matrix operator    
  * See also: [#matrix matrix], 
[#Table_of_Contents Top of the page] 
  	
    
== as_time == 

  * Possible use: 
    * OP(double) --->  string
  * Result: converts the given number into a string with hours, minutes and seconds  
  * Comment: as_time operator is a particular case (using a particular pattern) of the as_date operator.    
  * See also: [#as_date as_date], 
  {{{  
     as_time(22324234) 	--: 09:10:34
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== asin == 

  * Possible use: 
    * OP(float) --->  float
    * OP(int) --->  float
  * Result: the arcsin of the operand (which has to be expressed in decimal degrees).    
  * See also: [#acos acos], [#atan atan], 
  {{{  
     acos (90) → 1
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== at == 

  * Possible use: 
    * container OP KeyType --->  ValueType
    * species OP point --->  agent
    * species OP int --->  agent
    * string OP int --->  string
  * Result: the element at the right operand index of the container  
  * Comment: The first element of the container is located at the index 0. In addition, if the user tries to get the element at an index higher or equals than the length of the container, he will get an IndexOutOfBoundException.The at operator behavior depends on the nature of the operand
  * Special cases:
    * if it is a list or a matrix, at returns the element at the index specified by the right operand
    * if it is a map, at returns the value corresponding the right operand as key. If the right operand is not a key of the map, at returns nil
    * if it is a file, at returns the element of the file content at the index specified by the right operand
    * if it is a population, at returns the agent at the index specified by the right operand
    * if it is a graph and if the right operand is a node, at returns the in and out edges corresponding to that node
    * if it is a graph and if the right operand is an edge, at returns the pair node_out::node_in of the edge
    * if it is a graph and if the right operand is a pair node1::node2, at returns the edge from node1 to node2 in the graph    
  * See also: [#contains_all, contains_any contains_all, contains_any], 
  {{{  
     [1, 2, 3] at 2					--:    3 
     [{1,2}, {3,4}, {5,6}] at 0 	--: {1.0;2.0}
     'abcdef' at 0 	--: 'a';
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== at_distance == 

  * Possible use: 
    * species OP float --->  list
    * list OP float --->  list
  * Result: A list of agents among the left-operand list that are located at a distance <= the right operand from the caller agent (in its topology)
  * Special cases:
    * If the left operand is a species, return agents of the specified species (slightly more efficient than using list(species1), for instance)    
  * See also: [#neighbours_at neighbours_at], [#neighbours_of neighbours_of], [#agent_closest_to agent_closest_to], [#agents_inside agents_inside], [#closest_to closest_to], [#inside inside], [#overlapping overlapping], [#neighbours_at neighbours_at], [#neighbours_of neighbours_of], [#agent_closest_to agent_closest_to], [#agents_inside agents_inside], [#closest_to closest_to], [#inside inside], [#overlapping overlapping], 
  {{{  
     species1 at_distance 20 -> return the agents of species1 located at a distance <= 20 from the caller agent.
     [ag1, ag2, ag3] at_distance 20 -> return the agents of the list located at a distance <= 20 from the caller agent (in the same order).
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== at_location == 

  * Possible use: 
    * shape OP point --->  shape
  * Result: A geometry resulting from the tran of a translation to the right-hand operand point of the left-hand operand (geometry, agent, point)
  {{{  
     self at_location {10, 20} -> returns the geometry resulting from a translation to the location {10, 20} of the geometry of the agent applying the operator.
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== atan == 

  * Possible use: 
    * OP(int) --->  float
    * OP(float) --->  float
  * Result: the arctan of the operand (which has to be expressed in decimal degrees).    
  * See also: [#acos acos], [#asin asin], 
  {{{  
     atan (45) → 1
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== binomial == 

  * Possible use: 
    * OP(point) --->  int
  * Result: A value from a random variable following a binomial distribution. The operand {n,p} represents the number of experiments n and the success probability p.  
  * Comment: The binomial distribution is the discrete probability distribution of the number of successes in a sequence of n independent yes/no experiments, each of which yields success with probability p, cf. Binomial distribution on Wikipedia.    
  * See also: [#poisson poisson], [#gauss gauss], 
  {{{  
     binomial({15,0.6})  ->  a random positive integer
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== bool == 

  * Possible use: 
    * OP(any) --->  bool
  * Result: casting of the operand to a boolean value.
  * Special cases:
    * if the operand is null, returns false;
    * if the operand is an agent, returns true if the agent is not dead;
    * if the operand is an int or a float, returns true if it is not equal to 0 (or 0.0);
    * if the operand is a file, bool is formally equivalent to exists;
    * if the operand is a container, bool is formally equivalent to not empty (a la Lisp);
    * if the operand is a string, returns true is the operand is true;
    * Otherwise, returns false.
  {{{  
     bool(3.78) 		--: true
     bool(true) 		--: true
     bool({23, 4.0} 	--: false
     bool(5::34) 		--: false
     bool(green) 		--: false
     bool([1,5,9,3]) 	--: true
     bool(node1)		--: true
     bool('4')			--: false
     bool('4.7')		--: false 
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== ceil == 

  * Possible use: 
    * OP(double) --->  double
  * Result: maps the operand to the smallest following integer.  
  * Comment: More precisely, ceiling(x) is the smallest integer not less than x.    
  * See also: [#floor floor], [#round round], 
  {{{  
     ceil(3) 		--:  4.0
     ceil(3.5) 		--:  4.0
     ceil(-4.7) 	--:  -4.0
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== circle == 

  * Possible use: 
    * OP(float) --->  shape
  * Result: A circle geometry which radius is equal to the operand.  
  * Comment: the centre of the circle is by default the location of the current agent in which has been called this operator.
  * Special cases:
    * returns a point if the operand is lower or equal to 0.    
  * See also: [#around around], [#cone cone], [#line line], [#link link], [#norm norm], [#point point], [#polygon polygon], [#polyline polyline], [#rectangle rectangle], [#square square], [#triangle triangle], 
  {{{  
     circle(10) -> returns a geometry as a circle of radius 10.
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== clean == 

  * Possible use: 
    * OP(shape) --->  shape
  * Result: A geometry corresponding to the cleaning of the operand (geometry, agent, point)  
  * Comment: The cleaning corresponds to a buffer with a distance of 0.0
  {{{  
     cleaning(self) -> returns the geometry resulting from the cleaning of the geometry of the agent applying the operator.
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== closest_points_with == 

  * Possible use: 
    * shape OP shape --->  list of points
  * Result: A list of two closest points between the two geometries.    
  * See also: [#any_location_in any_location_in], [#any_point_in any_point_in], [#farthest_point_to farthest_point_to], [#points_at points_at], 
  {{{  
     geom1 closest_points_with(geom2) -> [pt1, pt2] with pt1 the closest point of geom1 to geom2 and pt1 the closest point of geom2 to geom1
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== closest_to == 

  * Possible use: 
    * species OP shape --->  agent
    * msi.gama.util.IContainer<?,msi.gama.metamodel.shape.IShape> OP shape --->  any
  * Result: An agent among the left-operand list, the closest to the operand (casted as a geometry).  
  * Comment: the distance is computed in the topology of the calling agent (the agent in which this operator is used), with the distance algorithm specific to the topology.
  * Special cases:
    * if the left-operand is a species, return an agent of the specified species.    
  * See also: [#neighbours_at neighbours_at], [#neighbours_of neighbours_of], [#neighbours_at neighbours_at], [#neighbours_of neighbours_of], [#inside inside], [#overlapping overlapping], [#agents_overlapping agents_overlapping], [#agents_inside agents_inside], [#agent_closest_to agent_closest_to], 
  {{{  
     neighbours_at
     neighbours_of
     species1 closest_to(self) -> return the closest agent of species species1 to the agent applying the operator.
     [ag1, ag2, ag3] closest_to(self) -> return the closest agent among ag1, ag2 and ag3 to the agent applying the operator.
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== collate == 

  * Possible use: 
    * OP(list) --->  list
  * Result: a new list containing interleaved elements of the operand  
  * Comment: the operand should be a list of lists of elements. The result is a list of elements. 
  * Special cases:
    * if the operand is nil or a list of (non-list) elements, accumulate returns an empty list
  {{{  
     collate([1,2,4,3,5,7,6,8]) 	--: 	[]
     collate([['e11','e12','e13'],['e21','e22','e23'],['e31','e32','e33']])  --:  [e11,e21,e31,e12,e22,e32,e13,e23,e33]
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== collect == 

  * Possible use: 
    * container OP any expression --->  list
  * Result: returns a new list, in which each element is the evaluation of the right-hand operand.  
  * Comment: collect is very similar to accumulate except. Nevertheless if the evaluation of the right-hand operand produces a list,the returned list is a list of list of elements. In contrarily, the list produces by accumulate is only a list of elements (all the lists) produced are concaneted. In addition, collect can be applied to any container.
  * Special cases:
    * if the left-hand operand is nil, accumulate returns an empty list    
  * See also: [#accumulate accumulate], 
  {{{  
     [1,2,4] collect (each *2)  	--: 	[2,4,8]
     [1,2,4] collect ([2,4])  		--: 	[[2,4],[2,4],[2,4]]
     [1::2, 3::4, 5::6] collect (each + 2) --: [8,4,6]
     (list(node) collect (node(each).location.x * 2)    --:  [25.65, 158.99, 140.80, 80.11, 125.47, 37.830, 4.62,...]
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== column_at == 

  * Possible use: 
    * matrix OP int --->  list
  * Result: returns the column at a num_col (rigth-hand operand)    
  * See also: [#row_at row_at], [#rows_list rows_list], 
  {{{  
     matrix([["el11","el12","el13"],["el21","el22","el23"],["el31","el32","el33"]]) column_at 2  --:  ["el31","el32","el33"]
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== columns_list == 

  * Possible use: 
    * OP(matrix) --->  list of lists
  * Result: returns a list of the columns of the matrix, with each column as a list of elements    
  * See also: [#rows_list rows_list], 
  {{{  
     columns_list(matrix([["el11","el12","el13"],["el21","el22","el23"],["el31","el32","el33"]])  --: 
     	  [["el11","el12","el13"],["el21","el22","el23"],["el31","el32","el33"]]
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== cone == 

  * Possible use: 
    * OP(point) --->  shape
  * Result: A cone geometry which min and max angles are given by the operands.  
  * Comment: the centre of the cone is by default the location of the current agent in which has been called this operator.
  * Special cases:
    * returns nil if the operand is nil.    
  * See also: [#around around], [#circle circle], [#line line], [#link link], [#norm norm], [#point point], [#polygon polygon], [#polyline polyline], [#rectangle rectangle], [#square square], [#triangle triangle], 
  {{{  
     cone({0, 45}) -> returns a geometry as a cone with min angle is 0 and max angle is 45.
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== container == 

  * Possible use: 
    * OP(any) --->  container
  * Result: casting of the operand to a container
  * Special cases:
    * if the operand is a container, returns itself
    * otherwise, returns the operand casted to a list    
  * See also: [#list list], 
[#Table_of_Contents Top of the page] 
  	
    
== contains == 

  * Possible use: 
    * string OP string --->  bool
    * container OP any --->  boolean
  * Result: true, if the container contains the right operand, false otherwise  
  * Comment: the contains operator behavior depends on the nature of the operand
  * Special cases:
    * if both operands are strings, returns true if the right-hand operand contains the right-hand pattern;
    * if it is a list or a matrix, contains returns true if the list or matrix contains the right operand
    * if it is a map, contains returns true if the operand is a key of the map
    * if it is a file, contains returns true it the operand is contained in the file content
    * if it is a population, contains returns true if the operand is an agent of the population, false otherwise
    * if it is a graph, contains returns true if the operand is a node or an edge of the graph, false otherwise    
  * See also: [#contains_all, contains_any contains_all, contains_any], 
  {{{  
     'abcded' contains 'bc' 	--:  true
     [1, 2, 3] contains 2	--:   true
     [{1,2}, {3,4}, {5,6}] contains {3,4}     --:   true
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== contains_all == 

  * Possible use: 
    * string OP list --->  bool
    * container OP container --->  bool
  * Result: true if the left operand contains all the elements of the right operand, false otherwise  
  * Comment: the definition of contains depends on the container
  * Special cases:
    * if the right operand is nil or empty, contains_all returns true    
  * See also: [#contains contains], [#contains_any contains_any], 
  {{{  
     "abcabcabc" contains_all ["ca","xy"] 	--: 	false
     [1,2,3,4,5,6] contains_all [2,4] 		--: 	true 
     [1,2,3,4,5,6] contains_all [2,8] 		--: 	false
     [1::2, 3::4, 5::6] contains_all [1,3] 	--: 	true 
     [1::2, 3::4, 5::6] contains_all [2,4] 	--: 	false
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== contains_any == 

  * Possible use: 
    * container OP container --->  bool
    * string OP list --->  bool
  * Result: true if the left operand contains one of the elements of the right operand, false otherwise  
  * Comment: the definition of contains depends on the container
  * Special cases:
    * if the right operand is nil or empty, contains_any returns false    
  * See also: [#contains contains], [#contains_all contains_all], 
  {{{  
     [1,2,3,4,5,6] contains_any [2,4] 		--: 	true 
     [1,2,3,4,5,6] contains_any [2,8] 		--: 	true
     [1::2, 3::4, 5::6] contains_any [1,3] 	--: 	true 
     [1::2, 3::4, 5::6] contains_any [2,4] 	--: 	false
     "abcabcabc" contains_any ["ca","xy"] 	--: 	true
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== contains_edge == 

  * Possible use: 
    * graph OP any --->  bool
    * graph OP pair --->  bool
  * Result: returns true if the graph(left-hand operand) contains the given edge (righ-hand operand), false otherwise
  * Special cases:
    * if the left-hand operand is nil, returns false
    * if the right-hand operand is a pair, returns true if it exists an edge between the two elements of the pair in the graph    
  * See also: [#contains_vertex contains_vertex], 
  {{{  
     let graphFromMap type: graph <-  as_edge_graph([{1,5}::{12,45},{12,45}::{34,56}]);
     graphFromMap contains_edge link({1,5}::{12,45})  --: true
     let graphEpidemio type: graph <- generate_barabasi_albert( ["edges_specy"::edge,"vertices_specy"::node,"size"::3,"m"::5] );
     graphEpidemio contains_edge (node(0)::node(3));   --:   true
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== contains_vertex == 

  * Possible use: 
    * msi.gama.util.graph.GamaGraph OP any --->  bool
  * Result: returns true if the graph(left-hand operand) contains the given vertex (righ-hand operand), false otherwise
  * Special cases:
    * if the left-hand operand is nil, returns false    
  * See also: [#contains_edge contains_edge], 
  {{{  
     let graphFromMap type: graph <-  as_edge_graph([{1,5}::{12,45},{12,45}::{34,56}]);
     graphFromMap contains_vertex {1,5}  --: true
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== convex_hull == 

  * Possible use: 
    * OP(shape) --->  shape
  * Result: A geometry corresponding to the convex hull of the operand.
  {{{  
     convex_hull(self) -> returns the convex hull of the geometry of the agent applying the operator
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== copy == 

  * Possible use: 
    * OP(any) --->  any
  * Result: returns a copy of the operand.
[#Table_of_Contents Top of the page] 
  	
    
== copy_between == 

  * Possible use: 
    * list OP point --->  list
    * string OP point --->  string
  * Result: returns a copy of a sublist of the left operand between a begin index (x of the right operand point) and a end index (y of the right operand point
  * Special cases:
    * if the right operand is nil or empty, copy_between returns a copy of the left operand
    * if the begin index is higher than the end index, copy_between returns a new empty list
  {{{  
     [1,2,3,4,5,6,7] copy_between {0,3} 	--:		 [1,2,3]
     "abcabcabc" copy_between {2,6}	--: 	cabc
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== cos == 

  * Possible use: 
    * OP(float) --->  float
    * OP(int) --->  float
  * Result: the cosinus of the operand (in decimal degrees).
  * Special cases:
    * the argument is casted to an int before being evaluated. Integers outside the range [0-359] are normalized.    
  * See also: [#sin sin], [#tan tan], 
  {{{  
     cos (0) → 1
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== count == 

  * Possible use: 
    * container OP any expression --->  int
  * Result: returns an int, equal to the number of elements of the left-hand operand that make the right-hand operand evaluate to true.  
  * Comment: in the right-hand operand, the keyword each can be used to represent, in turn, each of the elements.
  * Special cases:
    * if the left-hand operand is nil, count returns 0    
  * See also: [#group_by group_by], 
  {{{  
     [1,2,3,4,5,6,7,8] count (each > 3) 					--: 	5
     g2 count (length(g2 out_edges_of each) = 0  ) 			--: 	5	// Number of nodes of graph g2 without any out edge
     (list(node) count (round(node(each).location.x) > 32)  --:  	2 	// Number of agents node with x > 32
     [1::2, 3::4, 5::6] count (each > 4) 					--: 	1
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== crosses == 

  * Possible use: 
    * shape OP shape --->  bool
  * Result: A boolean, equal to true if the left-geometry (or agent/point) crosses the right-geometry (or agent/point).
  * Special cases:
    * if one of the operand is null, returns false.
    * if one operand is a point, returns false.    
  * See also: [#<-> <->], [#disjoint_from disjoint_from], [#intersects intersects], [#overlaps overlaps], [#partially_overlaps partially_overlaps], [#touches touches], 
  {{{  
     polyline([{10,10},{20,20}]) crosses polyline([{10,20},{20,10}]) -> true.
     polyline([{10,10},{20,20}]) crosses geometry({15,15}) -> false
     polyline([{0,0},{25,25}]) crosses polygon([{10,10},{10,20},{20,20},{20,10}]) -> true
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== dead == 

  * Possible use: 
    * OP(agent) --->  bool
  * Result: true if the agent is dead, false otherwise.
  {{{  
     dead(agent_A) 	--: 	true or false
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== directed == 

  * Possible use: 
    * OP(graph) --->  graph
  * Result: the operand graph becomes a directed graph.  
  * Comment: the operator alters the operand graph, it does not create a new one.    
  * See also: [#undirected undirected], 
[#Table_of_Contents Top of the page] 
  	
    
== direction_between == 

  * Possible use: 
    * topology OP msi.gama.util.IContainer<?,msi.gama.metamodel.shape.IShape> --->  int
  * Result: A direction (in degree) between a list of two geometries (geometries, agents, points) considering a topology.    
  * See also: [#towards towards], [#direction_to direction_to], [#distance_to distance_to], [#distance_between distance_between], [#path_between path_between], [#path_to path_to], 
  {{{  
     my_topology direction_between [ag1, ag2] -> the direction between ag1 and ag2 considering the topology my_topology
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== distance_between == 

  * Possible use: 
    * topology OP msi.gama.util.IContainer<?,msi.gama.metamodel.shape.IShape> --->  float
  * Result: A distance between a list of geometries (geometries, agents, points) considering a topology.    
  * See also: [#towards towards], [#direction_to direction_to], [#distance_to distance_to], [#direction_between direction_between], [#path_between path_between], [#path_to path_to], 
  {{{  
     my_topology distance_between [ag1, ag2, ag3] -> the distance between ag1, ag2 and ag3 considering the topology my_topology
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== distance_to == 

  * Possible use: 
    * shape OP shape --->  float
    * point OP point --->  float
  * Result: A distance between two geometries (geometries, agents or points) considering the topology of the agent applying the operator.    
  * See also: [#towards towards], [#direction_to direction_to], [#distance_between distance_between], [#direction_between direction_between], [#path_between path_between], [#path_to path_to], 
  {{{  
     ag1 distance_to ag2 -> the distance between ag1 and ag2 considering the topology of the agent applying the operator
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== div == 

  * Possible use: 
    * int OP float --->  int
    * float OP int --->  int
    * float OP float --->  int
    * int OP int --->  int
  * Result: an int, equal to the truncation of the division of the left-hand operand by the rigth-hand operand.
  * Special cases:
    * if the right-hand operand is equal to zero, raises an exception.    
  * See also: [#mod mod], 
  {{{  
     40 div 4.1		--:  9
     40 div 3 	--:  13
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== empty == 

  * Possible use: 
    * OP(container) --->  boolean
    * OP(string) --->  bool
  * Result: true if the operand is empty, false otherwise.  
  * Comment: the empty operator behavior depends on the nature of the operand
  * Special cases:
    * if it is a list, empty returns true if there is no element in the list, and false otherwise
    * if it is a map, empty returns true if the map contains no key-value mappings, and false otherwise
    * if it is a file, empty returns true if the content of the file (that is also a container) is empty, and false otherwise
    * if it is a population, empty returns true if there is no agent in the population, and false otherwise
    * if it is a graph, empty returns true if it contains no vertex and no edge, and false otherwise
    * if it is a matrix of int, float or object, it will return true if all elements are respectively 0, 0.0 or null, and false otherwise
    * if it is a matrix of geometry, it will return true if the matrix contains no cell, and false otherwise
    * if it is a string, empty returns true if the string does not contain any character, and false otherwise
  {{{  
     empty ([]) 	--: 	true;
     empty ('abced') 	--: 	false
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== eval_gaml == 

  * Possible use: 
    * OP(string) --->  any
  * Result: evaluates the given GAML string.    
  * See also: [#eval_java eval_java], 
  {{{  
     eval_gaml("2+3")    --:   5
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== eval_java == 

  * Possible use: 
    * OP(string) --->  any
  * Result: evaluates the given java code string.    
  * See also: [#eval_gaml eval_gaml], [#evaluate_with evaluate_with], 
[#Table_of_Contents Top of the page] 
  	
    
== evaluate_with == 

  * Possible use: 
    * string OP any expression --->  any
  * Result: evaluates the left-hand java expressions with the map of parameters (right-hand operand)    
  * See also: [#eval_gaml eval_gaml], [#eval_java eval_java], 
[#Table_of_Contents Top of the page] 
  	
    
== even == 

  * Possible use: 
    * OP(int) --->  bool
  * Result: true if the operand is even and false if it is odd.
  * Special cases:
    * if the operand is equal to 0, it returns true.
  {{{  
     even (3) 	--:   false
     even (-12)   --:  true
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== every == 

  * Possible use: 
    * OP(int) --->  bool
  * Result: true every operand time step, false otherwise  
  * Comment: the value of the every operator depends deeply on the time step. It can be used to do something not every step.
  {{{  
     reflex text_every {
     	if every(2) {write "the time step is even";}
     		else {write "the time step is odd";}
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== exp == 

  * Possible use: 
    * OP(float) --->  float
    * OP(int) --->  float
  * Result: returns Euler's number e raised to the power of the operand.
  * Special cases:
    * the operand is casted to a float before being evaluated.    
  * See also: [#ln ln], 
  {{{  
     exp (0) 	--:	 1
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== fact == 

  * Possible use: 
    * OP(int) --->  int
  * Result: the factorial of the operand.
  * Special cases:
    * if the operand is less than 0, fact returns 0.
  {{{  
     fact (4) 	--:	 24
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== farthest_point_to == 

  * Possible use: 
    * shape OP point --->  point
  * Result: the farthest point of the left-operand to the left-point.    
  * See also: [#any_location_in any_location_in], [#any_point_in any_point_in], [#closest_points_with closest_points_with], [#points_at points_at], 
  {{{  
     geom farthest_point_to(pt) -> the closest point of geom to pt
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== file == 

  * Possible use: 
    * OP(string) --->  msi.gama.util.file.IGamaFile
  * Result: opens a file in read only mode, creates a GAML file object, and tries to determine and store the file content in the contents attribute.  
  * Comment: The file should have a supported extension, see file type deifnition for supported file extensions.
  * Special cases:
    * If the specified string does not refer to an existing file, an exception is risen when the variable is used.    
  * See also: [#folder folder], [#new_folder new_folder], 
  {{{  
     let fileT type: file value: file("../includes/Stupid_Cell.Data"); 
     			// fileT represents the file "../includes/Stupid_Cell.Data"
     			// fileT.contents here contains a matrix storing all the data of the text file
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== first == 

  * Possible use: 
    * OP(string) --->  string
    * OP(species) --->  agent
    * OP(container) --->  ValueType
  * Result: the first element of the operand  
  * Comment: the first operator behavior depends on the nature of the operand
  * Special cases:
    * if it is a string, first returns a string composed of its first character
    * if it is a list, first returns the first element of the list, or nil if the list is empty
    * if it is a map, first returns nil (the map do not keep track of the order of elements)
    * if it is a file, first returns the first element of the content of the file (that is also a container)
    * if it is a population, first returns the first agent of the population
    * if it is a graph, first returns the first element in the list of vertexes
    * if it is a matrix, first returns the element at {0,0} in the matrix
    * for a matrix of int or float, it will return 0 if the matrix is empty
    * for a matrix of object or geometry, it will return null if the matrix is empty    
  * See also: [#last last], 
  {{{  
     first ('abce')      	--:   'a'
     first ([1, 2, 3]) 		--:   1
     first ({10,12})     	--:   10.
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== first_with == 

  * Possible use: 
    * container OP any expression --->  any
  * Result: the first element of the left-hand operand that makes the right-hand operand evaluate to true.  
  * Comment: in the right-hand operand, the keyword each can be used to represent, in turn, each of the right-hand operand elements. 
  * Special cases:
    * if the left-hand operand is nil, first_with returns nil    
  * See also: [#group_by group_by], [#last_with last_with], [#where where], 
  {{{  
     [1,2,3,4,5,6,7,8] first_with (each > 3) 						--: 	4
     g2 first_with (length(g2 out_edges_of each) = 0) 				--: 	node9
     (list(node) first_with (round(node(each).location.x) > 32)   	--: 	node2
     [1::2, 3::4, 5::6] first_with (each.key > 4) 					--: 	5::6
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== flip == 

  * Possible use: 
    * OP(float) --->  bool
  * Result: true or false given the probability represented by the operand
  * Special cases:
    * flip 0 always returns false, flip 1 true    
  * See also: [#rnd rnd], 
  {{{  
     flip (0.66666) -> 2/3 chances to return true.
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== float == 

  * Possible use: 
    * OP(any) --->  float
  * Result: casting of the operand to a floating point value.
  * Special cases:
    * if the operand is numerical value, returns its value as a floating point value;
    * if the operand is a string, tries to convert its content to a floating point value;
    * if the operand is a boolean, returns 1.0 for true and 0.0 for false;
    * otherwise, returns 0.0    
  * See also: [#int int], 
  {{{  
     float(7) 				--: 7.0
     float(true) 			--: 1.0
     float({23, 4.0} 		--: 0.0
     float(5::34) 			--: 0.0
     float(green) 			--: 0.0
     float([1,5,9,3]) 		--: 0.0
     float(node1)			--: 0.0
     int('4')				--: 4.0
     int('4.7')				--: 4.7 
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== floor == 

  * Possible use: 
    * OP(double) --->  double
  * Result: maps the operand to the largest previous following integer.  
  * Comment: More precisely, floor(x) is the largest integer not greater than x.    
  * See also: [#ceil ceil], [#round round], 
  {{{  
     floor(3) 		--:  3.0
     floor(3.5) 	--:  3.0
     floor(-4.7) 	--:  -5.0
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== folder == 

  * Possible use: 
    * OP(string) --->  msi.gama.util.file.IGamaFile
  * Result: opens an existing repository
  * Special cases:
    *  If the specified string does not refer to an existing repository, an exception is risen.    
  * See also: [#file file], [#new_folder new_folder], 
  {{{  
     let dirT type: file value: folder("../includes/");
     				// dirT represents the repository "../includes/"
     				// dirT.contents here contains the list of the names of included files
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== frequency_of == 

  * Possible use: 
    * container OP any expression --->  map
  * Result: Returns a map with keys equal to the application of the right-hand argument (like collect) and values equal to the frequency of this key (i.e. how many times it has been obtained)    
  * See also: [#as_map as_map], 
  {{{  
     [ag1, ag2, ag3, ag4] frequency_of each.size 	--:   will return the different sizes as keys and the number of agents of this size as values
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== gauss == 

  * Possible use: 
    * OP(point) --->  float
  * Result: A value from a normally distributed random variable with expected value (mean) and variance (standardDeviation). The probability density function of such a variable is a Gaussian.
  * Special cases:
    * when the operand is a point, it is read as {mean, standardDeviation}
    * when standardDeviation value is 0.0, it always returns the mean value    
  * See also: [#truncated_gauss truncated_gauss], [#poisson poisson], 
  {{{  
     gauss({0,0.3})  ->  0.22354
     gauss({0,0.3})  ->  -0.1357
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== generate_barabasi_albert == 

  * Possible use: 
    * OP(map) --->  graph
  * Result: returns a random scale-free network (following Barabasi–Albert (BA) model).  
  * Comment: The Barabasi–Albert (BA) model is an algorithm for generating random scale-free networks using a preferential attachment mechanism. A scale-free network is a network whose degree distribution follows a power law, at least asymptotically.Such networks are widely observed in natural and human-made systems, including the Internet, the world wide web, citation networks, and some social networks. [From Wikipedia article]The map operand should includes following elements:
  * Special cases:
    * "edges_specy": the species of edges
    * "vertices_specy": the species of vertices
    * "size": the graph will contain (size + 1) nodes
    * "m": the number of edges added per novel node    
  * See also: [#generate_watts_strogatz generate_watts_strogatz], 
  {{{  
     let graphEpidemio type: graph <- generate_barabasi_albert( [
     		"edges_specy"::edge,
     		"vertices_specy"::node,
     		"size"::3,
     		"m"::5] );
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== generate_watts_strogatz == 

  * Possible use: 
    * OP(map) --->  graph
  * Result: returns a random small-world network (following Watts-Strogatz model).  
  * Comment: The Watts-Strogatz model is a random graph generation model that produces graphs with small-world properties, including short average path lengths and high clustering.A small-world network is a type of graph in which most nodes are not neighbors of one another, but most nodes can be reached from every other by a small number of hops or steps. [From Wikipedia article]The map operand should includes following elements:
  * Special cases:
    * "edges_specy": the species of edges
    * "vertices_specy": the species of vertices
    * "size": the graph will contain (size + 1) nodes. Size must be greater than k.
    * "p": probability to "rewire" an edge. So it must be between 0 and 1. The parameter is often called beta in the literature.
    * "k": the base degree of each node. k must be greater than 2 and even.    
  * See also: [#generate_barabasi_albert generate_barabasi_albert], 
  {{{  
     let graphWatts type: graph <- generate_watts_strogatz( ["
     			"edges_specy"::edge,
     			"vertices_specy"::node,
     			"size"::2,
     			"p"::0.3,
     			"k"::0] );
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== geometric_mean == 

  * Possible use: 
    * OP(list) --->  float
  * Result: the geometric mean of the elements of the operand. See <A href="http://en.wikipedia.org/wiki/Geometric_mean">Geometric_mean</A> for more details.  
  * Comment: The operator casts all the numerical element of the list into float. The elements that are not numerical are discarded.    
  * See also: [#mean mean], [#median median], [#harmonic_mean harmonic_mean], 
  {{{  
     geometric_mean ([4.5, 3.5, 5.5, 7.0]) -> 4.962326343467649
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== geometry == 

  * Possible use: 
    * OP(any) --->  shape
  * Result: casts the operand into a geometry
  * Special cases:
    * if the operand is a point, returns a corresponding geometry point
    * if the operand is a agent, returns its geometry
    * if the operand is a population, returns the union of each agent geometry
    * if the operand is a pair of two agents or geometries, returns the link between the geometry of each element of the operand
    * if the operans is a graph, returns the corresponding multi-points geometry
    * if the operand is a container of points, if first and the last points are the same, returns the polygon built from these points
    * if the operand is a container, returns the union of the geometry of each element
    * otherwise, returns nil
  {{{  
     geometry({23, 4.0}) 					--: Point
     geometry(a_graph)						--: MultiPoint
     geometry(node1)						--: Point
     geometry([{0,0},{1,4},{4,8},{0,0}])	--: Polygon	
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== get == 

  * Possible use: 
    * shape OP string --->  any
  * Result: 
[#Table_of_Contents Top of the page] 
  	
    
== graph == 

  * Possible use: 
    * OP(any) --->  graph
  * Result: casting of the operand to a graph.
  * Special cases:
    * if the operand is a graph, returns the graph itself
    * if the operand is a list, returns a new graph with the elements of the left-hand operand as vertices and no edge. The graph will be spatial is the right-hand operand is true;
    * if the operand is a map, 
    * otherwise, returns nil
  {{{  
     graph([1,5,9,3]) 	--: ([1: in[] + out[], 3: in[] + out[], 5: in[] + out[], 9: in[] + out[]], [])
     graph(['a'::345, 'b'::13])  --:  ([b: in[] + out[b::13], a: in[] + out[a::345], 13: in[b::13] + out[], 345: in[a::345] + out[]], [a::345=(a,345), b::13=(b,13)])
     graph(a_graph)	--: a_graph
     graph(node1)	--: null
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== grid_at == 

  * Possible use: 
    * species OP point --->  agent
  * Result: 
[#Table_of_Contents Top of the page] 
  	
    
== group_by == 

  * Possible use: 
    * map OP any expression --->  map
    * container OP any expression --->  map
  * Result: a map, where the keys take the possible values of the right-hand operand and the map values are the list of elements of the left-hand operand associated to the key value  
  * Comment: in the right-hand operand, the keyword each can be used to represent, in turn, each of the right-hand operand elements. 
  * Special cases:
    * if the left-hand operand is nil, group_by returns a new empty map    
  * See also: [#first_with first_with], [#last_with last_with], [#where where], 
  {{{  
     [1,2,3,4,5,6,7,8] group_by (each > 3) 	--: 	[false::[1, 2, 3], true::[4, 5, 6, 7, 8]] 
     g2 group_by (length(g2 out_edges_of each) ) 	--: 	[ 0::[node9, node7, node10, node8, node11], 1::[node6], 2::[node5], 3::[node4]]
     (list(node) group_by (round(node(each).location.x))    --:  [32::[node5], 21::[node1], 4::[node0], 66::[node2], 96::[node3]]
     [1::2, 3::4, 5::6] group_by (each > 4) 	--: 	[false::[2, 4], true::[6]]
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== harmonic_mean == 

  * Possible use: 
    * OP(list) --->  float
  * Result: the harmonic mean of the elements of the operand. See <A href="http://en.wikipedia.org/wiki/Harmonic_mean">Harmonic_mean</A> for more details.  
  * Comment: The operator casts all the numerical element of the list into float. The elements that are not numerical are discarded.    
  * See also: [#mean mean], [#median median], [#geometric_mean geometric_mean], 
  {{{  
     	harmonic_mean ([4.5, 3.5, 5.5, 7.0]) -> 4.804159445407279
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== image == 

  * Possible use: 
    * OP(string) --->  msi.gama.util.file.IGamaFile
  * Result: opens a file that is a kind of image.  
  * Comment: The file should have an image extension, cf. file type deifnition for supported file extensions.
  * Special cases:
    * If the specified string does not refer to an existing image file, an exception is risen.    
  * See also: [#file file], [#shapefile shapefile], [#properties properties], [#text text], 
  {{{  
     let fileT type: file value: image("../includes/testImage.png");  // fileT represents the file "../includes/testShape.png"
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== in == 

  * Possible use: 
    * any OP container --->  bool
    * string OP string --->  bool
  * Result: true if the right operand contains the left operand, false otherwise  
  * Comment: the definition of in depends on the container
  * Special cases:
    * if the right operand is nil or empty, in returns false
    * if both operands are strings, returns true if the left-hand operand patterns is included in to the right-hand string;    
  * See also: [#contains contains], 
  {{{  
     2 in [1,2,3,4,5,6] : true
     7 in [1,2,3,4,5,6] : false
     3 in [1::2, 3::4, 5::6] : true
     6 in [1::2, 3::4, 5::6] : false
      'bc' in 'abcded' 	--:  true
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== in_edges_of == 

  * Possible use: 
    * graph OP any --->  list
  * Result: returns the list of the in-edges of a vertex (right-hand operand) in the graph given as left-hand operand.    
  * See also: [#out_edges_of out_edges_of], 
  {{{  
     graphEpidemio in_edges_of (node(3))   --:  [edge2,edge3]
     graphFromMap in_edges_of node({12,45})  --:  [LineString]
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== index_of == 

  * Possible use: 
    * list OP any --->  int
    * map OP any --->  any
    * matrix OP any --->  point
    * string OP string --->  int
  * Result: the index of the first occurence of the right operand in the left operand container  
  * Comment: The definition of index_of and the type of the index depend on the container
  * Special cases:
    * if the left operand is a list, index_of returns the index as an integer
    * if the left operand is a map, index_of returns the index as a pair
    * if the left operand is a matrix, index_of returns the index as a point
    * if both operands are strings, returns the index within the left-hand string of the first occurrence of the given right-hand string    
  * See also: [#at at], [#last_index_of last_index_of], 
  {{{  
     [1,2,3,4,5,6] index_of 4 	--: 	3
     [4,2,3,4,5,4] index_of 4  	--: 	0
     [1::2, 3::4, 5::6] index_of 4 		--: 	3::4
     matrix([[1,2,3],[4,5,6]]) index_of 4  	--: 	{1.0;0.0}
      "abcabcabc" index_of "ca" 	--: 	2
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== inside == 

  * Possible use: 
    * msi.gama.util.IContainer<?,msi.gama.metamodel.shape.IShape> OP any --->  list of agents
    * species OP any --->  list of agents
  * Result: A list of agents among the left-operand list, covered by the operand (casted as a geometry).
  * Special cases:
    * if the left-operand is a species, return agents of the specified species (slightly more efficient than using list(species1), for instance).    
  * See also: [#neighbours_at neighbours_at], [#neighbours_of neighbours_of], [#closest_to closest_to], [#overlapping overlapping], [#agents_overlapping agents_overlapping], [#agents_inside agents_inside], [#agent_closest_to agent_closest_to], 
  {{{  
     [ag1, ag2, ag3] inside(self) -> return the agents among ag1, ag2 and ag3 that are covered by the shape of the agent applying the operator.
     species1 inside(self) -> return the agents of species species1 that are covered by the shape of the agent applying the operator.
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== int == 

  * Possible use: 
    * OP(any) --->  int
  * Result: casting of the operand to an integer value.
  * Special cases:
    * if the operand is a float, returns its value truncated (but not rounded);
    * if the operand is an agent, returns its unique index;
    * if the operand is a string, tries to convert its content to an integer value;
    * if the operand is a boolean, returns 1 for true and 0 for false;
    * if the operand is a color, returns its RGB value as an integer;
    * otherwise, returns 0    
  * See also: [#round round], [#float float], 
  {{{  
     int(3.78) 			--: 3
     int(true) 			--: 1
     int({23, 4.0} 		--: 0
     int(5::34) 		--: 0
     int(green) 		--: -16711936
     int([1,5,9,3]) 	--: 0
     int(node1)			--: 1
     int('4')			--: 4
     int('4.7')			--:  // Exception 
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== inter == 

  * Possible use: 
    * container OP container --->  list
    * shape OP shape --->  shape
  * Result: the intersection of the two operandsA geometry resulting from the intersection between the two geometries  
  * Comment: both containers are transformed into sets (so without duplicated element, cf. remove_deplicates operator) before the set intersection is computed.
  * Special cases:
    * if an operand is a graph, it will be transformed into the set of its nodes
    * if an operand is a map, it will be transformed into the set of its values
    * if an operand is a matrix, it will be transformed into the set of the lines
    * returns false if the right-operand is nil    
  * See also: [#remove_duplicates remove_duplicates], [#union union], [#+ +], [#- -], 
  {{{  
     [1,2,3,4,5,6] inter [2,4] 				--: 	[2,4]
     [1,2,3,4,5,6] inter [0,8] 				--: 	[]
     [1::2, 3::4, 5::6] inter [2,4] 		--: 	[2,4]
     [1::2, 3::4, 5::6] inter [1,3] 		--: 	[]
     matrix([[1,2,3],[4,5,4]]) inter [3,4] 	--: 	[4,3]
     square(5) intersects {10,10} -> false
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== intersects == 

  * Possible use: 
    * shape OP point --->  bool
    * shape OP shape --->  bool
  * Result: A boolean, equal to true if the left-geometry (or agent/point) intersects the right-geometry (or agent/point).
  * Special cases:
    * if one of the operand is null, returns false.    
  * See also: [#<-> <->], [#disjoint_from disjoint_from], [#crosses crosses], [#overlaps overlaps], [#partially_overlaps partially_overlaps], [#touches touches], 
  {{{  
     square(5) intersects {10,10} -> false.
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== is == 

  * Possible use: 
    * any OP any expression --->  bool
  * Result: 
[#Table_of_Contents Top of the page] 
  	
    
== is_image == 

  * Possible use: 
    * OP(string) --->  bool
  * Result: the operator tests whether the operand represents the name of a supported image file  
  * Comment: cf. file type definition for supported (espacially image) file extensions.    
  * See also: [#image image], [#is_text is_text], [#is_properties is_properties], [#is_shape is_shape], 
  {{{  
     is_image("../includes/Stupid_Cell.Data")    --:  false;
     is_image("../includes/test.png")            --:  true;
     is_image("../includes/test.properties")     --:  false;
     is_image("../includes/test.shp")            --:  false;
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== is_number == 

  * Possible use: 
    * OP(string) --->  bool
  * Result: tests whether the operand represents a numerical value  
  * Comment: Note that the symbol . should be used for a float value (a string with , will not be considered as a numeric value). Symbols e and E are also accepted. A hexadecimal value should begin with #.
  {{{  
     is_number("test") 	--: false
     is_number("123.56") 	--: true
     is_number("-1.2e5") 	--: true
     is_number("1,2") 	--: false
     is_number("#12FA") 	--: true
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== is_properties == 

  * Possible use: 
    * OP(string) --->  bool
  * Result: the operator tests whether the operand represents the name of a supported properties file  
  * Comment: cf. file type definition for supported (espacially image) file extensions.    
  * See also: [#properties properties], [#is_text is_text], [#is_shape is_shape], [#is_image is_image], 
  {{{  
     is_properties("../includes/Stupid_Cell.Data")    --:  false;
     is_properties("../includes/test.png")            --:  false;
     is_properties("../includes/test.properties")     --:  true;
     is_properties("../includes/test.shp")            --:  false;
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== is_shape == 

  * Possible use: 
    * OP(string) --->  bool
  * Result: the operator tests whether the operand represents the name of a supported shapefile  
  * Comment: cf. file type definition for supported (espacially image) file extensions.    
  * See also: [#image image], [#is_text is_text], [#is_properties is_properties], [#is_image is_image], 
  {{{  
     is_shape("../includes/Stupid_Cell.Data")    --:  false;
     is_shape("../includes/test.png")            --:  false;
     is_shape("../includes/test.properties")     --:  false;
     is_shape("../includes/test.shp")            --:  true;
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== is_text == 

  * Possible use: 
    * OP(string) --->  bool
  * Result: the operator tests whether the operand represents the name of a supported text file  
  * Comment: cf. file type definition for supported (espacially image) file extensions.    
  * See also: [#text text], [#is_properties is_properties], [#is_shape is_shape], [#is_image is_image], 
  {{{  
     is_text("../includes/Stupid_Cell.Data")    --:  true;
     is_text("../includes/test.png")            --:  false;
     is_text("../includes/test.properties")     --:  false;
     is_text("../includes/test.shp")            --:  false;
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== last == 

  * Possible use: 
    * OP(container) --->  ValueType
    * OP(species) --->  agent
    * OP(string) --->  string
  * Result: the last element of the operand  
  * Comment: the last operator behavior depends on the nature of the operand
  * Special cases:
    * if it is a list, last returns the last element of the list, or nil if the list is empty
    * if it is a map, last returns nil (the map do not keep track of the order of elements)
    * if it is a file, last returns the last element of the content of the file (that is also a container)
    * if it is a population, last returns the last agent of the population
    * if it is a graph, last returns the last element in the list of vertexes
    * if it is a matrix, last returns the element at {length-1,length-1} in the matrix
    * for a matrix of int or float, it will return 0 if the matrix is empty
    * for a matrix of object or geometry, it will return null if the matrix is empty
    * if it is a string, last returns a string composed of its last character, or an empty string if the operand is empty    
  * See also: [#first first], 
  {{{  
     last ({10,12}) 	--:   12
     last ([1, 2, 3]) 	--:   3.
     last ('abce') 		--:   'e'
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== last_index_of == 

  * Possible use: 
    * string OP string --->  int
    * list OP any --->  int
    * map OP any --->  any
    * matrix OP any --->  point
  * Result: the index of the last occurence of the right operand in the left operand container  
  * Comment: The definition of last_index_of and the type of the index depend on the container
  * Special cases:
    * if both operands are strings, returns the index within the left-hand string of the rightmost occurrence of the given right-hand string
    * if the left operand is a list, last_index_of returns the index as an integer
    * if the left operand is a map, last_index_of returns the index as a pair
    * if the left operand is a matrix, last_index_of returns the index as a point    
  * See also: [#at at], [#last_index_of last_index_of], 
  {{{  
     "abcabcabc" last_index_of "ca" 	--: 	5
     [1,2,3,4,5,6] last_index_of 4  	--: 	3
     [4,2,3,4,5,4] last_index_of 4  	--: 	5
     [1::2, 3::4, 5::4] last_index_of 4  	--:  	5::4
     matrix([[1,2,3],[4,5,4]]) last_index_of 4  	--: 	{1.0;2.0}
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== last_with == 

  * Possible use: 
    * container OP any expression --->  any
  * Result: the last element of the left-hand operand that makes the right-hand operand evaluate to true.  
  * Comment: in the right-hand operand, the keyword each can be used to represent, in turn, each of the right-hand operand elements. 
  * Special cases:
    * if the left-hand operand is nil, last_with returns nil    
  * See also: [#group_by group_by], [#first_with first_with], [#where where], 
  {{{  
     [1,2,3,4,5,6,7,8] last_with (each > 3) 					--: 	8
     g2 last_with (length(g2 out_edges_of each) = 0 ) 			--: 	node11
     (list(node) last_with (round(node(each).location.x) > 32)  --: 	node3
     [1::2, 3::4, 5::6] last_with (each.key > 4) 				--: 	5::6
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== length == 

  * Possible use: 
    * OP(string) --->  int
    * OP(species) --->  int
    * OP(container) --->  int
  * Result: the number of elements contained in the operand  
  * Comment: the length operator behavior depends on the nature of the operand
  * Special cases:
    * if it is a string, length returns the number of characters
    * if it is a list or a map, length returns the number of elements in the list or map
    * if it is a population, length returns number of agents of the population
    * if it is a graph, last returns the number of vertexes or of edges (depending on the way it was created)
    * if it is a matrix, length returns the number of cells
  {{{  
     length ('I am an agent') 		--: 	13
     length ([12,13])	--: 	2
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== line == 

  * Possible use: 
    * OP(list of points) --->  shape
  * Result: A polyline geometry from the given list of points.
  * Special cases:
    * if the operand is nil, returns the point geometry {0,0}
    * if the operand is composed of a single point, returns a point geometry.    
  * See also: [#around around], [#circle circle], [#cone cone], [#link link], [#norm norm], [#point point], [#polygone polygone], [#rectangle rectangle], [#square square], [#triangle triangle], 
  {{{  
     polyline([{0,0}, {0,10}, {10,10}, {10,0}]) -> returns a polyline geometry composed of the 4 points.
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== link == 

  * Possible use: 
    * OP(pair) --->  shape
  * Result: A link between the 2 elements of the pair.  
  * Comment: The geometry of the link is the intersection of the two geometries when they intersect, and a line between their centroids when they do not.
  * Special cases:
    * if the operand is nil, link returns a point {0,0}
    * if one of the elements of the pair is a list of geometries or a species, link will consider the union of the geometries or of the geometry of each agent of the species    
  * See also: [#around around], [#circle circle], [#cone cone], [#line line], [#norm norm], [#point point], [#polygon polygon], [#polyline polyline], [#rectangle rectangle], [#square square], [#triangle triangle], 
  {{{  
     link (geom1::geom2)  -> returns a link geometry between geom1 and geom2.
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== list == 

  * Possible use: 
    * OP(container) --->  list
    * OP(any) --->  list
  * Result: transforms the operand into a list  
  * Comment: list always tries to cast the operand except if it is an int, a bool or a float; to create a list, instead, containing the operand (including another list), use the + operator on an empty list (like [] + 'abc').
  * Special cases:
    * if the operand is a point or a pair, returns a list containing its components (two coordinates or the key and the value);
    * if the operand is a rgb color, returns a list containing its three integer components;
    * if the operand is a file, returns its contents as a list;
    * if the operand is a matrix, returns a list containing its elements;
    * if the operand is a graph, returns the list of vetices or edges (depending on the graph)
    * if the operand is a species, return a list of its agents;
    * if the operand is a string, returns a list of strings, each containing one character;
    * otherwise returns a list containing the operand.
  {{{  
     
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== ln == 

  * Possible use: 
    * OP(int) --->  float
    * OP(float) --->  float
  * Result: returns the natural logarithm (base e) of the operand.
  * Special cases:
    * an exception is raised if the operand is less than zero.    
  * See also: [#exp exp], 
  {{{  
     ln(1) 	--:	 0.0
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== load_graph_from_dgs == 

  * Possible use: 
    * OP(map) --->  graph
  * Result: returns a graph loaded from a given file following DGS graph file format versions 1 and 2  
  * Comment: similar to load_graph_from_dgs_old    
  * See also: [#load_graph_from_dgs_old load_graph_from_dgs_old], 
[#Table_of_Contents Top of the page] 
  	
    
== load_graph_from_dgs_old == 

  * Possible use: 
    * OP(map) --->  graph
  * Result: returns a graph loaded from a given file following DGS file format (version 3).  
  * Comment: DGS is a file format allowing to store graphs and dynamic graphs in a textual human readable way, yet with a small size allowing to store large graphs. Graph dynamics is defined using events like adding, deleting or changing a node or edge. With DGS, graphs will therefore be seen as stream of such events. [From GraphStream related page: http://graphstream-project.org/]The map operand should includes following elements:
  * Special cases:
    * "filename": the filename of the file containing the network
    * "edges_specy": the species of edges
    * "vertices_specy": the species of vertices    
  * See also: [#load_graph_from_dgs load_graph_from_dgs], 
  {{{  
     let my_graph type: graph <- load_graph_from_dgs_old( [
     			"filename"::"../includes/BarabasiGenerated.dgs",
     			"edges_specy"::edgeSpecy,
     			"vertices_specy"::nodeSpecy] );
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== load_graph_from_dot == 

  * Possible use: 
    * OP(map) --->  graph
  * Result: returns a graph loaded from a given file following DOT file format.  
  * Comment: DOT is a plain text graph description language. It is a simple way of describing graphs that both humans and computer programs can use. See: http://en.wikipedia.org/wiki/DOT_language for more details.The map operand should includes following elements:
  * Special cases:
    * "filename": the filename of the file containing the network
    * "edges_specy": the species of edges
    * "vertices_specy": the species of vertices    
  * See also: [#load_graph_from_dgs_old load_graph_from_dgs_old], 
  {{{  
     let my_graph type: graph <- load_graph_from_dot( [
     			"filename"::"example_of_dot_file",
     			"edges_specy"::edgeSpecy,
     			"vertices_specy"::nodeSpecy] );
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== load_graph_from_edge == 

  * Possible use: 
    * OP(map) --->  graph
  * Result: returns a graph loaded from a given file following Edge file format.  
  * Comment: This format is a simple text file with numeric vertex ids defining the edges. The map operand should includes following elements:
  * Special cases:
    * "filename": the filename of the file containing the network
    * "edges_specy": the species of edges
    * "vertices_specy": the species of vertices    
  * See also: [#load_graph_from_dgs_old load_graph_from_dgs_old], 
  {{{  
     let my_graph type: graph <- load_graph_from_edge( [
     			"filename"::"example_of_edge_file",
     			"edges_specy"::edgeSpecy,
     			"vertices_specy"::nodeSpecy] );
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== load_graph_from_gexf == 

  * Possible use: 
    * OP(map) --->  graph
  * Result: returns a graph loaded from a given file following GEXF file format.  
  * Comment: GEXF (Graph Exchange XML Format) is a language for describing complex networks structures, their associated data and dynamics. Started in 2007 at Gephi project by different actors, deeply involved in graph exchange issues, the gexf specifications are mature enough to claim being both extensible and open, and suitable for real specific applications. See: http://gexf.net/format/ for more details.The map operand should includes following elements:
  * Special cases:
    * "filename": the filename of the file containing the network
    * "edges_specy": the species of edges
    * "vertices_specy": the species of vertices    
  * See also: [#load_graph_from_dgs_old load_graph_from_dgs_old], 
  {{{  
     let my_graph type: graph <- load_graph_from_gexf( [
     			"filename"::"example_of_Gexf_file",
     			"edges_specy"::edgeSpecy,
     			"vertices_specy"::nodeSpecy] );
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== load_graph_from_graphml == 

  * Possible use: 
    * OP(map) --->  graph
  * Result: returns a graph loaded from a given file following GEXF file format.  
  * Comment: GraphML is a comprehensive and easy-to-use file format for graphs based on XML.  See: http://graphml.graphdrawing.org/ for more details.The map operand should includes following elements:
  * Special cases:
    * "filename": the filename of the file containing the network
    * "edges_specy": the species of edges
    * "vertices_specy": the species of vertices    
  * See also: [#load_graph_from_dgs_old load_graph_from_dgs_old], 
  {{{  
     let my_graph type: graph <- load_graph_from_graphml( [
     			"filename"::"example_of_Graphml_file",
     			"edges_specy"::edgeSpecy,
     			"vertices_specy"::nodeSpecy] );
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== load_graph_from_lgl == 

  * Possible use: 
    * OP(map) --->  graph
  * Result: returns a graph loaded from a given file following LGL file format.  
  * Comment: LGL is a compendium of applications for making the visualization of large networks and trees tractable. See: http://lgl.sourceforge.net/ for more details.The map operand should includes following elements:
  * Special cases:
    * "filename": the filename of the file containing the network
    * "edges_specy": the species of edges
    * "vertices_specy": the species of vertices    
  * See also: [#load_graph_from_dgs_old load_graph_from_dgs_old], 
  {{{  
     let my_graph type: graph <- load_graph_from_lgl( [
     			"filename"::"example_of_LGL_file",
     			"edges_specy"::edgeSpecy,
     			"vertices_specy"::nodeSpecy] );
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== load_graph_from_ncol == 

  * Possible use: 
    * OP(map) --->  graph
  * Result: returns a graph loaded from a given file following ncol file format.  
  * Comment: This format is used by the Large Graph Layout progra. It is simply a symbolic weighted edge list. It is a simple text file with one edge per line. An edge is defined by two symbolic vertex names separated by whitespace. (The symbolic vertex names themselves cannot contain whitespace.) They might followed by an optional number, this will be the weight of the edge. See: http://bioinformatics.icmb.utexas.edu/lgl for more details.The map operand should includes following elements:
  * Special cases:
    * "filename": the filename of the file containing the network
    * "edges_specy": the species of edges
    * "vertices_specy": the species of vertices    
  * See also: [#load_graph_from_dgs_old load_graph_from_dgs_old], 
  {{{  
     let my_graph type: graph <- load_graph_from_ncol( [
     			"filename"::"example_of_ncol_file",
     			"edges_specy"::edgeSpecy,
     			"vertices_specy"::nodeSpecy] );
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== load_graph_from_pajek == 

  * Possible use: 
    * OP(map) --->  graph
  * Result: returns a graph loaded from a given file following Pajek file format.  
  * Comment: Pajek (Slovene word for Spider) is a program, for Windows, for analysis and visualization of large networks. See: http://pajek.imfm.si/doku.php?id=pajek for more details.The map operand should includes following elements:
  * Special cases:
    * "filename": the filename of the file containing the network
    * "edges_specy": the species of edges
    * "vertices_specy": the species of vertices    
  * See also: [#load_graph_from_dgs_old load_graph_from_dgs_old], 
  {{{  
     let my_graph type: graph <- load_graph_from_pajek( [
     			"filename"::"example_of_Pajek_file",
     			"edges_specy"::edgeSpecy,
     			"vertices_specy"::nodeSpecy] );
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== load_graph_from_tlp == 

  * Possible use: 
    * OP(map) --->  graph
  * Result: returns a graph loaded from a given file following TLP file format.  
  * Comment: TLP is the Tulip software graph format.  See: http://tulip.labri.fr/TulipDrupal/?q=tlp-file-format for more details.The map operand should includes following elements:
  * Special cases:
    * "filename": the filename of the file containing the network
    * "edges_specy": the species of edges
    * "vertices_specy": the species of vertices    
  * See also: [#load_graph_from_dgs_old load_graph_from_dgs_old], 
  {{{  
     let my_graph type: graph <- load_graph_from_tlp( [
     			"filename"::"example_of_TLP_file",
     			"edges_specy"::edgeSpecy,
     			"vertices_specy"::nodeSpecy] );
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== map == 

  * Possible use: 
    * OP(any) --->  map
    * OP(container) --->  java.util.Map
  * Result: casting of the operand to a map.
  * Special cases:
    * if the operand is a color RRGGBB, returns a map with the three elements: "r"::RR, "g"::GG, "b"::BB;
    * if the operand is a point, returns a map with two elements: "x":: x-ccordinate and "y":: y-coordinate;
    * if the operand is pair, returns a map with this only element;
    * if the operand is a species name, returns the map containing all the agents of the species as a pair nom_agent::agent;
    * if the operand is a agent, returns a map containing all the attributes as a pair attribute_name::attribute_value;
    * if the operand is a list, returns a map containing either elements of the list if it is a list of pairs, or pairs list.get(i)::list.get(i+1);
    * if the operand is a file, returns the content casted to map;
    * if the operand is a graph, returns the a map with pairs edge_source::edge_target;
    * otherwise returns a map containing only the pair operand::operand.
[#Table_of_Contents Top of the page] 
  	
    
== masked_by == 

  * Possible use: 
    * shape OP list of agents --->  shape
    * shape OP species --->  shape
  * Result: A geometry representing the part of the right operand visible from the point of view of the agent using the operator while considering the obstacles defined by the left operand
  {{{  
     perception_geom masked_by obstacle_list -> returns the geometry representing the part of perception_geom visible from the agent position considering the list of obstacles obstacle_list.
     perception_geom masked_by obstacle_species -> returns the geometry representing the part of perception_geom visible from the agent position considering the obstacles of species obstacle_species.
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== matrix == 

  * Possible use: 
    * OP(list) --->  matrix
    * OP(container) --->  matrix
    * OP(any) --->  matrix
  * Result: casts the operand into a matrix
  * Special cases:
    * if the operand is a file, returns its content casted as a matrix
    * if the operand is a map, returns a 2-columns matrix with keyx in the first one and value in the second one;
    * if the operand is a list, returns a 1-row matrix. Notice that each element of the list should be a single element or lists with the same length;
    * if the operand is a graph, returns nil;
    * otherwise, returns a 1x1 matrix with the operand at the (0,0) position.    
  * See also: [#as_matrix as_matrix], 
[#Table_of_Contents Top of the page] 
  	
    
== max == 

  * Possible use: 
    * OP(container) --->  ValueType
  * Result: the maximum element found in the operand  
  * Comment: the max operator behavior depends on the nature of the operand
  * Special cases:
    * if it is a list of int of float, max returns the maximum of all the elements
    * if it is a list of points: max returns the maximum of all points as a point (i.e. the point with the greatest coordinate on the x-axis, in case of equality the point with the greatest coordinate on the y-axis is chosen. If all the points are equal, the first one is returned. )
    * if it is a population of a list of other type: max transforms all elements into integer and returns the maximum of them
    * if it is a map, max returns the maximum among the list of all elements value
    * if it is a file, max returns the maximum of the content of the file (that is also a container)
    * if it is a graph, max returns the maximum of the list of the elements of the graph (that can be the list of edges or vertexes depending on the graph)
    * if it is a matrix of int, float or object, max returns the maximum of all the numerical elements (thus all elements for integer and float matrices)
    * if it is a matrix of geometry, max returns the maximum of the list of the geometries
    * if it is a matrix of another type, max returns the maximum of the elements transformed into float    
  * See also: [#min min], 
  {{{  
     max ([100, 23.2, 34.5]) 	--: 	100.0
     max([{1.0;3.0},{3.0;5.0},{9.0;1.0},{7.0;8.0}]) 	--:  {9.0;1.0}
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== max_of == 

  * Possible use: 
    * container OP any expression --->  any
  * Result: the maximum value of the right-hand expression evaluated on each of the elements of the left-hand operand  
  * Comment: in the right-hand operand, the keyword each can be used to represent, in turn, each of the right-hand operand elements. 
  * Special cases:
    * if the left-hand operand is nil, max_of returns the right-hand operand default value    
  * See also: [#min_of min_of], 
  {{{  
     [1,2,4,3,5,7,6,8] max_of (each * 100 ) 			--: 	800
     g2 max_of (length(g2 out_edges_of each) ) 			--: 	3
     (list(node) max_of (round(node(each).location.x))  --: 	96
     [1::2, 3::4, 5::6] max_of (each.value + 3) 		--: 	9
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== mean == 

  * Possible use: 
    * OP(container) --->  any
  * Result: the mean of all the elements of the operand  
  * Comment: the elements of the operand are summed (see sum for more details about the sum of container elements ) and then the sum value is divided by the number of elements.
  * Special cases:
    * if the container contains points, the result will be a point    
  * See also: [#sum sum], 
  {{{  
     mean ([4.5, 3.5, 5.5, 7.0]) -> 5.125 
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== mean_deviation == 

  * Possible use: 
    * OP(list) --->  float
  * Result: the deviation from the mean of all the elements of the operand. See <A href= "http://en.wikipedia.org/wiki/Absolute_deviation" >Mean_deviation</A> for more details.  
  * Comment: The operator casts all the numerical element of the list into float. The elements that are not numerical are discarded.    
  * See also: [#mean mean], [#standard_deviation standard_deviation], 
  {{{  
     mean_deviation ([4.5, 3.5, 5.5, 7.0]) -> 1.125
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== median == 

  * Possible use: 
    * OP(list) --->  float
  * Result: the median of all the elements of the operand.  
  * Comment: The operator casts all the numerical element of the list into float. The elements that are not numerical are discarded.    
  * See also: [#mean mean], 
  {{{  
     median ([4.5, 3.5, 5.5, 7.0]) -> 5.0
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== min == 

  * Possible use: 
    * OP(container) --->  ValueType
  * Result: the minimum element found in the operand.  
  * Comment: the min operator behavior depends on the nature of the operand
  * Special cases:
    * if it is a list of int or float: min returns the minimum of all the elements
    * if it is a list of points: min returns the minimum of all points as a point (i.e. the point with the smallest coordinate on the x-axis, in case of equality the point with the smallest coordinate on the y-axis is chosen. If all the points are equal, the first one is returned. )
    * if it is a population of a list of other types: min transforms all elements into integer and returns the minimum of them
    * if it is a map, min returns the minimum among the list of all elements value
    * if it is a file, min returns the minimum of the content of the file (that is also a container)
    * if it is a graph, min returns the minimum of the list of the elements of the graph (that can be the list of edges or vertexes depending on the graph)
    * if it is a matrix of int, float or object, min returns the minimum of all the numerical elements (thus all elements for integer and float matrices)
    * if it is a matrix of geometry, min returns the minimum of the list of the geometries
    * if it is a matrix of another type, min returns the minimum of the elements transformed into float    
  * See also: [#max max], 
  {{{  
     min ([100, 23.2, 34.5]) 	--: 	23.2
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== min_of == 

  * Possible use: 
    * container OP any expression --->  any
  * Result: the minimum value of the right-hand expression evaluated on each of the elements of the left-hand operand  
  * Comment: in the right-hand operand, the keyword each can be used to represent, in turn, each of the right-hand operand elements. 
  * Special cases:
    * if the left-hand operand is nil, first_with returns nil    
  * See also: [#max_of max_of], 
  {{{  
     [1,2,4,3,5,7,6,8] min_of (each * 100 ) 			--: 	100
     g2 min_of (length(g2 out_edges_of each) ) 			--: 	0
     (list(node) min_of (round(node(each).location.x))  --: 	4
     [1::2, 3::4, 5::6] min_of (each.value + 3) 				--: 	5
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== mod == 

  * Possible use: 
    * int OP int --->  int
  * Result: an int, equal to the remainder of the integer division of the left-hand operand by the rigth-hand operand.
  * Special cases:
    * if the right-hand operand is equal to zero, raises an exception.    
  * See also: [#div div], 
  {{{  
     40 mod 3 		--:  1
     40 mod 4		--:  0
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== mul == 

  * Possible use: 
    * OP(container) --->  any
  * Result: the product of all the elements of the operand  
  * Comment: the mul operator behavior depends on the nature of the operand
  * Special cases:
    * if it is a list of int or float: mul returns the product of all the elements
    * if it is a list of points: mul returns the product of all points as a point (each coordinate is the product of the corresponding coordinate of each element)
    * if it is a list of other types: mul transforms all elements into integer and multiplies them
    * if it is a map, mul returns the product of the value of all elements
    * if it is a file, mul returns the product of the content of the file (that is also a container)
    * if it is a graph, mul returns the product of the list of the elements of the graph (that can be the list of edges or vertexes depending on the graph)
    * if it is a matrix of int, float or object, mul returns the product of all the numerical elements (thus all elements for integer and float matrices)
    * if it is a matrix of geometry, mul returns the product of the list of the geometries
    * if it is a matrix of other types: mul transforms all elements into float and multiplies them    
  * See also: [#sum sum], 
  {{{  
     mul ([100, 23.2, 34.5]) 	--:		80040.0
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== neighbours_at == 

  * Possible use: 
    * shape OP float --->  list
    * point OP float --->  list
  * Result: a list, containing all the agents located at a distance inferior or equal to the right-hand operand to the left-hand operand (geometry, agent, point).  
  * Comment: The topology used to compute the neighbourhood  is the one of the left-operand if this one is an agent; otherwise the one of the agent applying the operator.    
  * See also: [#neighbours_of neighbours_of], [#closest_to closest_to], [#overlapping overlapping], [#agents_overlapping agents_overlapping], [#agents_inside agents_inside], [#agent_closest_to agent_closest_to], [#at_distance at_distance], 
  {{{  
     (self neighbours_at (10)) -> returns all the agents located at a distance lower or equal to 10 to the agent applying the operator.
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== neighbours_of == 

  * Possible use: 
    * topology OP agent --->  list
    * graph OP any --->  list
    * topology OP pair --->  list
  * Result: a list, containing all the agents located at a distance inferior or equal to 1 to the right-hand operand agent considering the left-hand operand topology.returns the list of neighbours of the given vertex (right-hand operand) in the given graph (left-hand operand)
  * Special cases:
    * a list, containing all the agents located at a distance inferior or equal to the right member (float) of the pair (right-hand operand) to the left member (agent, geometry or point) considering the left-hand operand topology.    
  * See also: [#neighbours_at neighbours_at], [#closest_to closest_to], [#overlapping overlapping], [#agents_overlapping agents_overlapping], [#agents_inside agents_inside], [#agent_closest_to agent_closest_to], [#predecessors_of predecessors_of], [#successors_of successors_of], 
  {{{  
     topology(self) neighbours_of self -> returns all the agents located at a distance lower or equal to 1 to the agent applying the operator considering its topology.
     graphEpidemio neighbours_of (node(3)) 		--:	[node0,node2]
     graphFromMap neighbours_of node({12,45}) 	--: [{1.0;5.0},{34.0;56.0}]
     topology(self) neighbours_of self::10-> returns all the agents located at a distance lower or equal to 10 to the agent applying the operator considering its topology.
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== new_folder == 

  * Possible use: 
    * OP(string) --->  msi.gama.util.file.IGamaFile
  * Result: opens an existing repository or create a new folder if it does not exist.
  * Special cases:
    *  If the specified string does not refer to an existing repository, the repository is created. If the string refers to an existing file, an exception is risen.    
  * See also: [#folder folder], [#file file], 
  {{{  
     let dirNewT type: file value: new_folder("../incl/");   	// dirNewT represents the repository "../incl/"
     															// eventually creates the directory ../incl
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== norm == 

  * Possible use: 
    * OP(point) --->  float
  * Result: the norm of the vector with the coordinnates of the point operand.
  {{{  
     norm({3,4})   --:	  5.0
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== of_generic_species == 

  * Possible use: 
    * container OP species --->  list
  * Result: a list, containing the agents of the left-hand operand whose species is that denoted by the right-hand operand and whose species extends the right-hand operand species     
  * See also: [#of_species of_species], 
  {{{  
     // species test {}
     // species sous_test parent: test {}
     [sous_test(0),sous_test(1),test(2),test(3)] of_generic_species test 		--: [sous_test0,sous_test1,test2,test3]
     [sous_test(0),sous_test(1),test(2),test(3)] of_generic_species sous_test 	--: [sous_test0,sous_test1]
     [sous_test(0),sous_test(1),test(2),test(3)] of_species test 				--: [test2,test3]
     [sous_test(0),sous_test(1),test(2),test(3)] of_species sous_test 			--: [sous_test0,sous_test1]
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== of_species == 

  * Possible use: 
    * container OP species --->  list
  * Result: a list, containing the agents of the left-hand operand whose species is that denoted by the right-hand operand.The expression agents of_species (species self) is equivalent to agents where (species each = species self); however, the advantage of using the first syntax is that the resulting list is correctly typed with the right species, whereas, in the second syntax, the parser cannot determine the species of the agents within the list (resulting in the need to cast it explicitely if it is to be used in an ask statement, for instance).
  * Special cases:
    * if the right operand is nil, of_species returns the right operand    
  * See also: [#of_generic_species of_generic_species], 
  {{{  
     (self neighbours_at 10) of_species (species (self)) 	--:  all the neighbouring agents of the same species.
     [test(0),test(1),node(1),node(2)] of_species test 		--:  [test0,test1]
     [1,2,3,4,5,6] of_species test							--:	 []
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== one_of == 

  * Possible use: 
    * OP(species) --->  agent
    * OP(container) --->  ValueType
  * Result: a random element from the listone of the values stored in this container using GAMA.getRandom()  
  * Comment: the one_of operator behavior depends on the nature of the operand
  * Special cases:
    * if the list is empty, returns nil 
    * If the operand is a species, the operand is casted to a list before the expression is evaluated. Therefore, if foo is the name of a species, any(foo) will return a random agent from this species (see list)
    * if the operand is empty, one_of returns nil
    * if it is a list or a matrix, one_of returns one of the elements of the list or of the matrix
    * if it is a map, one_of returns one of the values of the map
    * if it is a graph, one_of returns one of the nodes of the graph
    * if it is a file, one_of returns one of the elements of the content of the file (that is also a container)
    * if it is a population, one_of returns one of the agents of the population
  {{{  
     one_of (bug) -> bug3     // The species `bug` has previously be defined
     any ([1,2,3]) 		--: 	1, 2, or 3
     one_of ([1,2,3]) 	--:	 	1, 2, or 3
     one_of ([2::3, 4::5, 6::7]) 	--: 	3, 5 or 7
     // The species bug has previously been defined
     one_of (bug) 		--:		 bug3
     let mat3 type:matrix value: matrix([["c11","c12","c13"],["c21","c22","c23"]])
     one_of(mat3) 		--: 	 "c11","c12","c13", "c21","c22" or "c23"
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== or == 

  * Possible use: 
    * bool OP any expression --->  bool
  * Result: a bool value, equal to the logical or between the left-hand operand and the rigth-hand operand.  
  * Comment: both operands are always casted to bool before applying the operator. Thus, an expression like 1 or 0 is accepted and returns true.    
  * See also: [#bool bool], [#and and], 
[#Table_of_Contents Top of the page] 
  	
    
== out_edges_of == 

  * Possible use: 
    * graph OP any --->  list
  * Result: returns the list of the out-edges of a vertex (right-hand operand) in the graph given as left-hand operand.    
  * See also: [#in_edges_of in_edges_of], 
  {{{  
     graphEpidemio out_edges_of (node(3))   --:   []
     graphFromMap out_edges_of {12,45}      --: [LineString]
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== overlapping == 

  * Possible use: 
    * msi.gama.util.IContainer<?,msi.gama.metamodel.shape.IShape> OP any --->  list of agents
    * species OP any --->  list of agents
  * Result: A list of agents a mong the left-operand list, overlapping the operand (casted as a geometry).
  * Special cases:
    * if the left-operand is a species, return agents of the specified species.    
  * See also: [#neighbours_at neighbours_at], [#neighbours_of neighbours_of], [#agent_closest_to agent_closest_to], [#agents_inside agents_inside], [#closest_to closest_to], [#inside inside], [#agents_overlapping agents_overlapping], 
  {{{  
     [ag1, ag2, ag3] overlapping(self) -> return the agents among ag1, ag2 and ag3 that overlap the shape of the agent applying the operator.
     species1 overlapping(self) -> return the agents of species species1 that overlap the shape of the agent applying the operator.
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== overlaps == 

  * Possible use: 
    * shape OP shape --->  bool
  * Result: A boolean, equal to true if the left-geometry (or agent/point) overlaps the right-geometry (or agent/point).
  * Special cases:
    * if one of the operand is null, returns false.
    * if one operand is a point, returns true if the point is included in the geometry    
  * See also: [#<-> <->], [#disjoint_from disjoint_from], [#crosses crosses], [#intersects intersects], [#partially_overlaps partially_overlaps], [#touches touches], 
  {{{  
     polyline([{10,10},{20,20}]) overlaps polyline([{15,15},{25,25}]) -> true
     polygon([{10,10},{10,20},{20,20},{20,10}]) overlaps polygon([{15,15},{15,25},{25,25},{25,15}]) -> true
     polygon([{10,10},{10,20},{20,20},{20,10}]) overlaps geometry({25,25}) -> true
     polygon([{10,10},{10,20},{20,20},{20,10}]) overlaps polygon([{35,35},{35,45},{45,45},{45,35}]) -> false
     polygon([{10,10},{10,20},{20,20},{20,10}]) overlaps polyline([{10,10},{20,20}]) -> true
     polygon([{10,10},{10,20},{20,20},{20,10}]) overlaps geometry({15,15}) -> true
     polygon([{10,10},{10,20},{20,20},{20,10}]) overlaps polygon([{0,0},{0,30},{30,30}, {30,0}]) -> true
     polygon([{10,10},{10,20},{20,20},{20,10}]) overlaps polygon([{15,15},{15,25},{25,25},{25,15}]) -> true
     polygon([{10,10},{10,20},{20,20},{20,10}]) overlaps polygon([{10,20},{20,20},{20,30},{10,30}]) -> true
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== pair == 

  * Possible use: 
    * OP(any) --->  pair
  * Result: casting of the operand to a pair value.
  * Special cases:
    * if the operand is null, returns null;
    * if the operand is a point, returns the pair x-coordinate::y-coordinate;
    * if the operand is a particular kind of geometry, a link between geometry, returns the pair formed with these two geoemtries;
    * if the operand is a map, returns the pair where the first element is the list of all the keys of the map and the second element is the list of all the values of the map;
    * if the operand is a list, returns a pair with the two first element of the list used to built the pair
    * if the operand is a link, returns a pair source_link::destination_link
    * Otherwise, returns the pair string(operand)::operand.
  {{{  
     pair(true) 							--: true::true
     pair({23, 4.0} 						--: 23.0::4.0
     pair([1,5,9,3]) 						--: 1::5
     pair([[3,7],[2,6,9],0]) 				--: [3,7]::[2,6,9]
     pair(['a'::345, 'b'::13, 'c'::12])  	--: [b,c,a]::[13,12,345]
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== partially_overlaps == 

  * Possible use: 
    * shape OP shape --->  bool
  * Result: A boolean, equal to true if the left-geometry (or agent/point) partially overlaps the right-geometry (or agent/point).  
  * Comment: if one geometry operand fully covers the other geometry operand, returns false (contrarily to the overlaps operator).
  * Special cases:
    * if one of the operand is null, returns false.    
  * See also: [#<-> <->], [#disjoint_from disjoint_from], [#crosses crosses], [#overlaps overlaps], [#intersects intersects], [#touches touches], 
  {{{  
     polyline([{10,10},{20,20}]) partially_overlaps polyline([{15,15},{25,25}]) -> true
     polygon([{10,10},{10,20},{20,20},{20,10}]) partially_overlaps polygon([{15,15},{15,25},{25,25},{25,15}]) -> true
     polygon([{10,10},{10,20},{20,20},{20,10}]) partially_overlaps geometry({25,25}) -> true
     polygon([{10,10},{10,20},{20,20},{20,10}]) partially_overlaps polygon([{35,35},{35,45},{45,45},{45,35}]) -> false
     polygon([{10,10},{10,20},{20,20},{20,10}]) partially_overlaps polyline([{10,10},{20,20}]) -> false
     polygon([{10,10},{10,20},{20,20},{20,10}]) partially_overlaps geometry({15,15}) -> false
     polygon([{10,10},{10,20},{20,20},{20,10}]) partially_overlaps polygon([{0,0},{0,30},{30,30}, {30,0}]) -> false
     polygon([{10,10},{10,20},{20,20},{20,10}]) partially_overlaps polygon([{15,15},{15,25},{25,25},{25,15}]) -> true
     polygon([{10,10},{10,20},{20,20},{20,10}]) partially_overlaps polygon([{10,20},{20,20},{20,30},{10,30}]) -> false
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== path == 

  * Possible use: 
    * OP(any) --->  path
  * Result: casting of the operand to a path
  * Special cases:
    * if the operand is a path, returns itself
    * if the operand is a list, casts the list into a list of point and returns the path (in the current topology) through these points.
    * otherwise, returns nil    
  * See also: [#graph graph], 
  {{{  
     path([{2,5}, {4,7}, {2,1}])   --:  [polyline ([{2.0,5.0},{4.0,7.0}]),polyline ([{4.0,7.0},{2.0,1.0}])]
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== path_between == 

  * Possible use: 
    * topology OP msi.gama.util.IContainer<?,msi.gama.metamodel.shape.IShape> --->  path
  * Result: A path between a list of two geometries (geometries, agents or points) considering a topology.    
  * See also: [#towards towards], [#direction_to direction_to], [#distance_between distance_between], [#direction_between direction_between], [#path_to path_to], [#distance_to distance_to], 
  {{{  
     my_topology path_between [ag1, ag2] -> A path between ag1 and ag2
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== path_to == 

  * Possible use: 
    * shape OP shape --->  path
    * point OP point --->  path
  * Result: A path between two geometries (geometries, agents or points) considering the topology of the agent applying the operator.    
  * See also: [#towards towards], [#direction_to direction_to], [#distance_between distance_between], [#direction_between direction_between], [#path_between path_between], [#distance_to distance_to], 
  {{{  
     ag1 path_to ag2 -> the path between ag1 and ag2 considering the topology of the agent applying the operator
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== point == 

  * Possible use: 
    * OP(any) --->  point
  * Result: casting of the operand to a point value.
  * Special cases:
    * if the operand is null, returns null;
    * if the operand is an agent, returns its location
    * if the operand is a geometry, returns its centroid
    * if the operand is a list with at least two elements, returns a point with the two first elements of the list (casted to float)
    * if the operand is a map, returns the point with values associated respectively with keys "x" and "y"
    * if the operand is a pair, returns a point with the two elements of the pair (casted to float)
    * otherwise, returns a point {val,val} where val is the float value of the operand
  {{{  
     point(0) 								--: {0.0;0.0}
     point(true) 							--: {1.0;1.0}
     point(5::34) 							--: {5.0;34.0}
     point([1,5,9,3]) 						--: {1.0;5.0}
     point([[3,7],[2,6,9],0]) 				--:{0.0;0.0}
     point(['a'::345, 'y'::13, 'c'::12])  	--:  {0.0;13.0}
     point(node1)							--: {64.06165572529225;18.401233796267537}   // centroid of node1 shape
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== points_at == 

  * Possible use: 
    * int OP float --->  list
  * Result: A list of left-operand number of points located at a the right-operand distance to the agent location.    
  * See also: [#any_location_in any_location_in], [#any_point_in any_point_in], [#closest_points_with closest_points_with], [#farthest_point_to farthest_point_to], 
  {{{  
     3 points_at(20.0) -> returns [pt1, pt2, pt3] with pt1, pt2 and pt3 located at a distance of 20.0 to the agent location
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== poisson == 

  * Possible use: 
    * OP(float) --->  int
  * Result: A value from a random variable following a Poisson distribution (with the positive expected number of occurence lambda as operand).  
  * Comment: The Poisson distribution is a discrete probability distribution that expresses the probability of a given number of events occurring in a fixed interval of time and/or space if these events occur with a known average rate and independently of the time since the last event, cf. Poisson distribution on Wikipedia.    
  * See also: [#binomial binomial], [#gauss gauss], 
  {{{  
     poisson(3.5) -> a random positive integer
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== polygon == 

  * Possible use: 
    * OP(list of points) --->  shape
  * Result: A polygon geometry from the given list of points.
  * Special cases:
    * if the operand is nil, returns the point geometry {0,0}
    * if the operand is composed of a single point, returns a point geometry
    * if the operand is composed of 2 points, returns a polyline geometry.    
  * See also: [#around around], [#circle circle], [#cone cone], [#line line], [#link link], [#norm norm], [#point point], [#polyline polyline], [#rectangle rectangle], [#square square], [#triangle triangle], 
  {{{  
     polygon([{0,0}, {0,10}, {10,10}, {10,0}]) -> returns a polygon geometry composed of the 4 points.
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== predecessors_of == 

  * Possible use: 
    * graph OP any --->  list
  * Result: returns the list of predecessors (i.e. sources of in edges) of the given vertex (right-hand operand) in the given graph (left-hand operand)    
  * See also: [#neighbours_of neighbours_of], [#successors_of successors_of], 
  {{{  
     graphEpidemio predecessors_of (node(3)) 		--: [node0,node2]
     graphFromMap predecessors_of node({12,45}) 	--:	[{1.0;5.0}]
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== properties == 

  * Possible use: 
    * OP(string) --->  msi.gama.util.file.IGamaFile
  * Result: opens a file that is a kind of properties.  
  * Comment: The file should have a properties extension, cf. type file definition for supported file extensions.
  * Special cases:
    * If the specified string does not refer to an existing propserites file, an exception is risen.    
  * See also: [#file file], [#shapefile shapefile], [#image image], [#text text], 
  {{{  
     let fileT type: file value: properties("../includes/testProperties.properties");  // fileT represents the properties file "../includes/testProperties.properties"
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== read == 

  * Possible use: 
    * OP(string) --->  any
    * OP(msi.gama.util.file.IGamaFile) --->  any
  * Result: marks the file so that only read operations are allowed.  
  * Comment: A file is created by default in read-only mode. The operator write can change the mode.    
  * See also: [#file file], [#write write], 
  {{{  
     read(shapefile("../images/point_eau.shp"))  --:  returns a file in read-only mode representing "../images/point_eau.shp"
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== rectangle == 

  * Possible use: 
    * OP(point) --->  shape
  * Result: A rectangle geometry which side sizes are given by the operands.  
  * Comment: the centre of the rectangle is by default the location of the current agent in which has been called this operator.
  * Special cases:
    * returns nil if the operand is nil.    
  * See also: [#around around], [#circle circle], [#cone cone], [#line line], [#link link], [#norm norm], [#point point], [#polygon polygon], [#polyline polyline], [#square square], [#triangle triangle], 
  {{{  
     rectangle({10, 5}) -> returns a geometry as a rectangle with width = 10 and heigh = 5.
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== remove_duplicates == 

  * Possible use: 
    * OP(container) --->  list
  * Result: produces a set from the elements of the operand (i.e. a list without duplicated elements)
  * Special cases:
    * if the operand is nil, remove_duplicates returns nil
    * if the operand is a graph, remove_duplicates returns the set of nodes
    * if the operand is a map, remove_duplicates returns the set of values without duplicate
    * if the operand is a matrix, remove_duplicates returns a matrix withtout duplicated row
  {{{  
     remove_duplicates([3,2,5,1,2,3,5,5,5]) --: [3,2,5,1]
     remove_duplicates([1::3,2::4,3::3,5::7]) --: [3,4,7]
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== remove_node_from == 

  * Possible use: 
    * shape OP graph --->  graph
  * Result: removes a node from a graph.  
  * Comment: all the edges containing this node are also removed.
  {{{  
     node(0) remove_node_from graphEpidemio;    --: 	returns the graph without node(0)
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== reverse == 

  * Possible use: 
    * OP(string) --->  string
    * OP(container) --->  container
  * Result: the operand elements in the reversed order in a copy of the operand.  
  * Comment: the reverse operator behavior depends on the nature of the operand
  * Special cases:
    * if it is a string, reverse returns a new string with caracters in the reversed order
    * if it is a list, reverse returns a copy of the operand list with elements in the reversed order
    * if it is a map, reverse returns a copy of the operand map with each pair in the reversed order (i.e. all keys become values and values become keys)
    * if it is a file, reverse returns a copy of the file with a reversed content
    * if it is a population, reverse returns a copy of the population with elements in the reversed order
    * if it is a graph, reverse returns a copy of the graph (with all edges and vertexes), with all of the edges reversed
    * if it is a matrix, reverse returns a new matrix containing the transpose of the operand.
  {{{  
     reverse ('abcd') 		--: 	'dcba';
     reverse ([10,12,14]) 				--: 	[14, 12, 10]
     reverse ([k1::44, k2::32, k3::12]) --: 	[12::k3,  32::k2, 44::k1]
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== rewire_n == 

  * Possible use: 
    * graph OP int --->  graph
  * Result: rewires the given count of edges.  
  * Comment: If there are too many edges, all the edges will be rewired.    
  * See also: [#rewire_p rewire_p], 
  {{{  
     set graphEpidemio <- graphEpidemio rewire_n 10;
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== rewire_p == 

  * Possible use: 
    * graph OP float --->  graph
  * Result: Rewires a graph (in the Watts-Strogatz meaning)    
  * See also: [#rewire_p rewire_p], 
  {{{  
     set graphEpidemio <- graphEpidemio rewire_p 0.2;
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== rgb == 

  * Possible use: 
    * OP(any) --->  rgb
  * Result: casting of the operand to a rgb color.
  * Special cases:
    * if the operand is nil, returns white;
    * if the operand is a string, the allowed color names are the constants defined in the java.awt.Color class, i.e.: black, blue, cyan, darkGray, lightGray, gray, green, magenta, orange, pink, red, white, yellow. Otherwise tries to cast the string to an int and returns this color
    * if the operand is a list, the integer value associated to the three first elements of the list are used to define the three red (element 0 of the list), green (element 1 of the list) and blue (element 2 of the list) components of the color;
    * if the operand is a map, the red, green, blue components take the value associated to the keys "r", "g", "b" in the map;
    * if the operand is a matrix, return the color of the matrix casted as a list;
    * if the operand is a boolean, returns black for true and white for false;
    * if the operand is an integer value, the decimal integer is translated into a hexadecimal value: OxRRGGBB. The red (resp. green, blue) component of the color take the value RR (resp. GG, BB) translated in decimal.
  {{{  
     rgb(3.78) 			--: rgb([0,0,3])
     rgb(true) 			--: rgb([0,0,0]) //black 
     rgb({23, 4.0} 		--: rgb([0,0,0]) //black 
     rgb(5::34) 		--: rgb([0,0,0]) //black 
     rgb(green) 		--: rgb([0,255,0]) //green 
     rgb([1,5,9,3]) 	--: rgb([1,5,9])
     rgb(node1)			--: rgb([0,0,1])
     rgb('4')			--: rgb([0,0,4])
     rgb('4.7')			--:  // Exception 
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== rnd == 

  * Possible use: 
    * OP(point) --->  point
    * OP(float) --->  int
    * OP(int) --->  int
  * Result: a random integer in the interval [0, operand]  
  * Comment: to obtain a probability between 0 and 1, use the expression (rnd n) / n, where n is used to indicate the precision
  * Special cases:
    * if the operand is a point, returns a point with two random integers in the interval [0, operand]
    * if the operand is a float, it is casted to an int before being evaluated    
  * See also: [#flip flip], 
  {{{  
     rnd ({2.5,3}) -> {x,y} with x in [0,2] and y in [0,3]
     rnd (2.5) -> 0, 1 or 2
     rnd (2) -> 0, 1 or 2
     rnd (1000) / 1000 -> a float between 0 and 1 with a precision of 0.001
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== rotated_by == 

  * Possible use: 
    * shape OP int --->  shape
    * shape OP float --->  shape
  * Result: A geometry resulting from the application of a rotation by the right-hand operand angle (degree) to the left-hand operand (geometry, agent, point)  
  * Comment: the right-hand operand can be a float or a int    
  * See also: [#transformed_by transformed_by], [#translated_by translated_by], 
  {{{  
     self rotated_by 45 -> returns the geometry resulting from a 45 degres rotation to the geometry of the agent applying the operator.
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== round == 

  * Possible use: 
    * OP(float) --->  int
    * OP(int) --->  int
  * Result: the rounded value of the operand.
  * Special cases:
    * if the operand is an int, round returns it    
  * See also: [#int int], [#with_precision with_precision], 
  {{{  
     round (0.51) 	--:	 1
     round (100.2) 	--: 	 100
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== row_at == 

  * Possible use: 
    * matrix OP int --->  list
  * Result: returns the row at a num_line (rigth-hand operand)    
  * See also: [#column_at column_at], [#columns_list columns_list], 
  {{{  
     matrix([["el11","el12","el13"],["el21","el22","el23"],["el31","el32","el33"]]) row_at 2  --:  ["el13","el23","el33"]
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== rows_list == 

  * Possible use: 
    * OP(matrix) --->  list of lists
  * Result: returns a list of the rows of the matrix, with each row as a list of elements    
  * See also: [#columns_list columns_list], 
  {{{  
     rows_list(matrix([["el11","el12","el13"],["el21","el22","el23"],["el31","el32","el33"]])   --: 
      		[["el11","el21","el31"],["el12","el22","el32"],["el13","el23","el33"]]
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== set_verbose == 

  * Possible use: 
    * graph OP bool --->  graph
  * Result: sets the verbose attributes of the graph (left-hand operand) to the given boolean value (right-hand operand).  
  * Comment: When verbose of a graph is true, it will display the shortest path computation level with static optimizer. This operator is useful to monitor the computation of     
  * See also: [#with_optimizer_type with_optimizer_type], 
  {{{  
     set graphEpidemio <- graphEpidemio set_verbose false;
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== shapefile == 

  * Possible use: 
    * OP(string) --->  msi.gama.util.file.IGamaFile
  * Result: opens a file that a is a kind of shapefile.  
  * Comment: The file should have a shapefile extension, cf. file type definition for supported file extensions.
  * Special cases:
    * If the specified string does not refer to an existing shapefile file, an exception is risen.    
  * See also: [#file file], [#properties properties], [#image image], [#text text], 
  {{{  
     let fileT type: file value: shapefile("../includes/testProperties.shp");
                 // fileT represents the shapefile file "../includes/testProperties.shp"
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== shuffle == 

  * Possible use: 
    * OP(list) --->  list
    * OP(matrix) --->  matrix
    * OP(species) --->  list
    * OP(string) --->  string
  * Result: The elements of the operand in random order.
  * Special cases:
    * if the operand is empty, returns an empty list (or string, matrix)    
  * See also: [#reverse reverse], 
  {{{  
     shuffle ([12, 13, 14]) -> [14,12,13];
     shuffle ([["c11","c12","c13"],["c21","c22","c23"]]) -> [["c12","c21","c11"],["c13","c22","c23"]]
     shuffle (bug) ->  shuffle the list of all agents of the `bug` species
     shuffle ('abc') -> 'bac'
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== simple_clustering_by_distance == 

  * Possible use: 
    * list of agents OP float --->  list
  * Result: A list of agent groups clustered by distance considering a distance min between two groups.  
  * Comment: use of hierarchical clustering with Minimum for linkage criterion between two groups of agents.    
  * See also: [#simple_clustering_by_envelope_distance simple_clustering_by_envelope_distance], 
  {{{  
     [ag1, ag2, ag3, ag4, ag5] simpleClusteringByDistance 20.0 -> for example, can return [[ag1, ag3], [ag2], [ag4, ag5]]
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== simple_clustering_by_envelope_distance == 

  * Possible use: 
    * list of agents OP float --->  list
  * Result: A list of agent groups clustered by distance (considering the agent envelop) considering a distance min between two groups.  
  * Comment: use of hierarchical clustering with Minimum for linkage criterion between two groups of agents.    
  * See also: [#simple_clustering_by_distance simple_clustering_by_distance], 
  {{{  
     [ag1, ag2, ag3, ag4, ag5] simpleClusteringByDistance 20.0 -> for example, can return [[ag1, ag3], [ag2], [ag4, ag5]]
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== simplification == 

  * Possible use: 
    * shape OP float --->  shape
  * Result: A geometry corresponding to the simplification of the operand (geometry, agent, point) considering a tolerance distance.  
  * Comment: The algorithm used for the simplification is Douglas-Peucker
  {{{  
     self simplification 0.1 -> returns the geometry resulting from the application of the Douglas-Peuker algorithm on the geometry of the agent applying the operator with a tolerance distance of 0.1.
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== sin == 

  * Possible use: 
    * OP(float) --->  float
    * OP(int) --->  float
  * Result: the sinus of the operand (in decimal degrees).
  * Special cases:
    * the argument is casted to an int before being evaluated. Integers outside the range [0-359] are normalized.    
  * See also: [#cos cos], [#tan tan], 
  {{{  
     cos (0) → 0
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== skeletonize == 

  * Possible use: 
    * OP(shape) --->  list of shapes
  * Result: A list of geometries (polylines) corresponding to the skeleton of the operand geometry (geometry, agent)
  {{{  
     skeletonize(self) -> returns the list of geometries corresponding to the skeleton of the geometry of the agent applying the operator.
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== sort_by == 

  * Possible use: 
    * container OP any expression --->  list
    * map OP any expression --->  map
  * Result: a list, containing the elements of the left-hand operand sorted in ascending order by the value of the right-hand operand when it is evaluated on them.   
  * Comment: the left-hand operand is casted to a list before applying the operator. In the right-hand operand, the keyword each can be used to represent, in turn, each of the elements.
  * Special cases:
    * if the left-hand operand is nil, sort_by returns  nil    
  * See also: [#group_by group_by], 
  {{{  
     [1,2,4,3,5,7,6,8] sort_by (each) 					--: 	[1,2,3,4,5,6,7,8]
     g2 sort_by (length(g2 out_edges_of each) ) 		--: 	[node9, node7, node10, node8, node11, node6, node5, node4]
     (list(node) sort_by (round(node(each).location.x)) --:  	[node5, node1, node0, node2, node3]
     [1::2, 3::4, 5::6] sort_by (each) 				--: 	
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== source_of == 

  * Possible use: 
    * graph OP any --->  any
  * Result: returns the source of the edge (right-hand operand) contained in the graph given in left-hand operand.
  * Special cases:
    * if the lef-hand operand (the graph) is nil, throws an Exception    
  * See also: [#target_of target_of], 
  {{{  
     let graphEpidemio type: graph <- generate_barabasi_albert( ["edges_specy"::edge,"vertices_specy"::node,"size"::3,"m"::5] );
     graphEpidemio source_of(edge(3)) 				--:  node1
     let graphFromMap type: graph <-  as_edge_graph([{1,5}::{12,45},{12,45}::{34,56}]);
     graphFromMap source_of(link({1,5}::{12,45}))  	--: {1.0;5.0}
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== species == 

  * Possible use: 
    * OP(any) --->  species
  * Result: casting of the operand to a species.
  * Special cases:
    * if the operand is nil, returns nil;
    * if the operand is an agent, returns its species;
    * if the operand is a string, returns the species with this name (nil if not found);
    * otherwise, returns nil
  {{{  
     species(self)			--: species of the current agent
     species('node')		--: node
     species([1,5,9,3]) 	--: null
     species(node1)			--: node
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== split_at == 

  * Possible use: 
    * shape OP point --->  list of shapes
  * Result: The two part of the left-operand lines split at the given right-operand point
  * Special cases:
    * if the left-operand is a point or a polygon, returns an empty list
  {{{  
     polyline([{1,2},{4,6}]) split_at {7,6}  -> [polyline([{1.0;2.0},{7.0;6.0}]), polyline([{7.0;6.0},{4.0;6.0}])].
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== split_lines == 

  * Possible use: 
    * OP(list) --->  list of shapes
  * Result: A list of geometries resulting after cutting the lines at their intersections.
  {{{  
     split_lines([line([{0,10}, {20,10}], line([{0,10}, {20,10}]]) -> returns a list of four polylines: line([{0,10}, {10,10}]), line([{10,10}, {20,10}]), line([{10,0}, {10,10}]) and line([{10,10}, {10,20}]).
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== split_with == 

  * Possible use: 
    * string OP string --->  list
  * Result: a list, containing the sub-strings (tokens) of the left-hand operand delimited by each of the characters of the right-hand operand.  
  * Comment: delimiters themselves are excluded from the resulting list
  {{{  
     'to be or not to be,that is the question' split_with ' ,'  --:  [to,be,or,not,to,be,that,is,the,question]
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== sqrt == 

  * Possible use: 
    * OP(int) --->  float
    * OP(float) --->  float
  * Result: returns the square root of the operand.
  * Special cases:
    * if the operand is negative, an exception is raised
  {{{  
     sqrt(4) 	--:	 2.0
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== square == 

  * Possible use: 
    * OP(float) --->  shape
  * Result: A square geometry which side size is equal to the operand.  
  * Comment: the centre of the square is by default the location of the current agent in which has been called this operator.
  * Special cases:
    * returns nil if the operand is nil.    
  * See also: [#around around], [#circle circle], [#cone cone], [#line line], [#link link], [#norm norm], [#point point], [#polygon polygon], [#polyline polyline], [#rectangle rectangle], [#triangle triangle], 
  {{{  
     square(10) -> returns a geometry as a square of side size 10.
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== standard_deviation == 

  * Possible use: 
    * OP(list) --->  float
  * Result: the standard deviation on the elements of the operand. See <A href="http://en.wikipedia.org/wiki/Standard_deviation">Standard_deviation</A> for more details.  
  * Comment: The operator casts all the numerical element of the list into float. The elements that are not numerical are discarded.    
  * See also: [#mean mean], [#mean_deviation mean_deviation], 
  {{{  
     standard_deviation ([4.5, 3.5, 5.5, 7.0]) -> 1.2930100540985752
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== string == 

  * Possible use: 
    * OP(any) --->  string
  * Result: casting of the operand to a string.
  * Special cases:
    * if the operand is nil, returns 'nil';
    * if the operand is an agent, returns its name;
    * if the operand is a string, returns the operand;
    * if the operand is an int or a float, returns their string representation (as in Java);
    * if the operand is a boolean, returns 'true' or 'false';
    * if the operand is a species, returns its name;
    * if the operand is a color, returns its litteral value if it has been created with one (i.e. 'black', 'green', etc.) or the string representation of its hexadecimal value.
    * if the operand is a container, returns its string representation.
  {{{  
     string(0) 			--: 0
     string({23, 4.0} 	--: {23.0;4.0}
     string(5::34) 		--: 5::34
     string(['a'::345, 'b'::13, 'c'::12])  --:  b,13; c,12; a,345;
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== successors_of == 

  * Possible use: 
    * graph OP any --->  list
  * Result: returns the list of successors (i.e. targets of out edges) of the given vertex (right-hand operand) in the given graph (left-hand operand)    
  * See also: [#predecessors_of predecessors_of], [#neighbours_of neighbours_of], 
  {{{  
     graphEpidemio successors_of (node(3)) 		--: []
     graphFromMap successors_of node({12,45}) 	--: [{34.0;56.0}]
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== sum == 

  * Possible use: 
    * OP(container) --->  any
  * Result: the sum of all the elements of the operand  
  * Comment: the sum operator behavior depends on the nature of the operand
  * Special cases:
    * if it is a list of int or float: sum returns the sum of all the elements
    * if it is a list of points: sum returns the sum of all points as a point (each coordinate is the sum of the corresponding coordinate of each element)
    * if it is a population or a list of other types: sum transforms all elements into integer and sums them
    * if it is a map, sum returns the sum of the value of all elements
    * if it is a file, sum returns the sum of the content of the file (that is also a container)
    * if it is a graph, sum returns the sum of the list of the elements of the graph (that can be the list of edges or vertexes depending on the graph)
    * if it is a matrix of int, float or object, sum returns the sum of all the numerical elements (i.e. all elements for integer and float matrices)
    * if it is a matrix of geometry, sum returns the sum of the list of the geometries
    * if it is a matrix of other types: sum transforms all elements into float and sums them    
  * See also: [#mul mul], 
  {{{  
     sum ([12,10, 3]) 	--: 	25.0
     sum([{1.0;3.0},{3.0;5.0},{9.0;1.0},{7.0;8.0}])		--: {20.0;17.0} 
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== tan == 

  * Possible use: 
    * OP(int) --->  float
    * OP(float) --->  float
  * Result: the trigonometic tangent of the operand (in decimal degrees).
  * Special cases:
    * the argument is casted to an int before being evaluated. Integers outside the range [0-359] are normalized.    
  * See also: [#cos cos], [#sin sin], 
  {{{  
     cos (180) → 0
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== tanh == 

  * Possible use: 
    * OP(float) --->  float
    * OP(int) --->  float
  * Result: the hyperbolic tangent of the operand (which has to be expressed in decimal degrees).
  {{{  
     tanh(0)  	--: 0.0
     tanh(1)  	--: 0.7615941559557649
     tanh(10) 	--: 0.9999999958776927
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== target_of == 

  * Possible use: 
    * graph OP any --->  any
  * Result: returns the target of the edge (right-hand operand) contained in the graph given in left-hand operand.
  * Special cases:
    * if the lef-hand operand (the graph) is nil, returns nil    
  * See also: [#source_of source_of], 
  {{{  
     let graphEpidemio type: graph <- generate_barabasi_albert( ["edges_specy"::edge,"vertices_specy"::node,"size"::3,"m"::5] );
     graphEpidemio source_of(edge(3)) 				--:  node1
     let graphFromMap type: graph <-  as_edge_graph([{1,5}::{12,45},{12,45}::{34,56}]);
     graphFromMap source_of(link({1,5}::{12,45}))  	--: {1.0;5.0}
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== text == 

  * Possible use: 
    * OP(string) --->  msi.gama.util.file.IGamaFile
  * Result: opens a file that a is a kind of text.  
  * Comment: The file should have a text extension, cf. file type definition for supported file extensions.
  * Special cases:
    * If the specified string does not refer to an existing text file, an exception is risen.    
  * See also: [#file file], [#properties properties], [#image image], [#shapefile shapefile], 
  {{{  
     let fileT type: file value: text("../includes/Stupid_Cell.Data");
     				// fileT represents the text file "../includes/Stupid_Cell.Data"
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== times == 

  * Possible use: 
    * matrix OP matrix --->  matrix
  * Result: 
[#Table_of_Contents Top of the page] 
  	
    
== to_gaml == 

  * Possible use: 
    * OP(any) --->  string
  * Result: represents the gaml way to write an expression in gaml, depending on its type    
  * See also: [#to_java to_java], 
  {{{  
     to_gaml(0) 							--: 0
     to_gaml(3.78) 							--: 3.78
     to_gaml(true) 							--: true
     to_gaml({23, 4.0}) 					--: {23.0,4.0}
     to_gaml(5::34) 						--: (5)::(34)
     to_gaml(green) 						--: rgb (-16711936)
     to_gaml('hello')						--: 'hello'
     to_gaml([1,5,9,3]) 					--: [1,5,9,3]
     to_gaml(['a'::345, 'b'::13, 'c'::12])  --:  ([('b')::(13),('c')::(12),('a')::(345)] as map )
     to_gaml([[3,5,7,9],[2,4,6,8]])			--: [3,2,5,4,7,6,9,8] as matrix
     to_gaml(a_graph)						--: ([((1 as node)::(3 as node))::(5 as edge),((0 as node)::(3 as node))::(3 as edge),((1 as node)::(2 as node))::(1 as edge),((0 as node)::(2 as node))::(2 as edge),((0 as node)::(1 as node))::(0 as edge),((2 as node)::(3 as node))::(4 as edge)] as map ) as graph
     to_gaml(node1)							--: 1 as node
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== to_java == 

  * Possible use: 
    * OP(any) --->  string
  * Result: represents the java way to write an expression in java, depending on its type  
  * Comment: NOT YET IMPLEMENTED    
  * See also: [#to_gaml to_gaml], 
[#Table_of_Contents Top of the page] 
  	
    
== topology == 

  * Possible use: 
    * OP(any) --->  topology
  * Result: casting of the operand to a topology.
  * Special cases:
    * if the operand is a topology, returns the topology itself;
    * if the operand is a spatial graph, returns the graph topology associated;
    * if the operand is a population, returns the topology of the population;
    * if the operand is a shape or a geometry, returns the continuous topology bounded by the geometry;
    * if the operand is a matrix, returns the grid topology associated
    * if the operand is another kind of container, returns the multiple topology associated to the container
    * otherwise, casts the operand to a geometry and build a topology from it.    
  * See also: [#geometry geometry], 
  {{{  
     topology(0) 		--: null
     topology(a_graph)	--: Multiple topology in POLYGON ((24.712119771887785 7.867357373616512, 24.712119771887785 61.283226839310565, 82.4013676510046  7.867357373616512)) at location[53.556743711446195;34.57529210646354]
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== touches == 

  * Possible use: 
    * shape OP shape --->  bool
  * Result: A boolean, equal to true if the left-geometry (or agent/point) touches the right-geometry (or agent/point).  
  * Comment: returns true when the left-operand only touches the right-operand. When one geometry covers partially (or fully) the other one, it returns false.
  * Special cases:
    * if one of the operand is null, returns false.    
  * See also: [#<-> <->], [#disjoint_from disjoint_from], [#crosses crosses], [#overlaps overlaps], [#partially_overlaps partially_overlaps], [#intersects intersects], 
  {{{  
     polyline([{10,10},{20,20}]) touches geometry({15,15}) -> false
     polyline([{10,10},{20,20}]) touches geometry({10,10}) -> true
     geometry({15,15}) touches geometry({15,15}) -> false
     polyline([{10,10},{20,20}]) touches polyline([{10,10},{5,5}]) -> true
     polyline([{10,10},{20,20}]) touches polyline([{5,5},{15,15}]) -> false
     polyline([{10,10},{20,20}]) touches polyline([{15,15},{25,25}]) -> false
     polygon([{10,10},{10,20},{20,20},{20,10}]) touches polygon([{15,15},{15,25},{25,25},{25,15}]) -> false
     polygon([{10,10},{10,20},{20,20},{20,10}]) touches polygon([{10,20},{20,20},{20,30},{10,30}]) -> true
     polygon([{10,10},{10,20},{20,20},{20,10}]) touches polygon([{10,10},{0,10},{0,0},{10,0}]) -> true
     polygon([{10,10},{10,20},{20,20},{20,10}]) touches geometry({15,15}) -> false
     polygon([{10,10},{10,20},{20,20},{20,10}]) touches geometry({10,15}) -> true
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== towards == 

  * Possible use: 
    * shape OP shape --->  int
  * Result: The direction (in degree) between the two geometries (geometries, agents, points) considering the topology of the agent applying the operator.    
  * See also: [#distance_between distance_between], [#distance_to distance_to], [#direction_between direction_between], [#path_between path_between], [#path_to path_to], 
  {{{  
     ag1 towards ag2 -> the direction between ag1 and ag2 and ag3 considering the topology of the agent applying the operator
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== transformed_by == 

  * Possible use: 
    * shape OP point --->  shape
  * Result: A geometry resulting from the application of a rotation and a translation (rigth-operand : point {angle(degree), distance} of the left-hand operand (geometry, agent, point)    
  * See also: [#rotated_by rotated_by], [#translated_by translated_by], 
  {{{  
     self transformed_by {45, 20} -> returns the geometry resulting from 45¡ rotation and 10m translation of the geometry of the agent applying the operator.
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== translated_by == 

  * Possible use: 
    * shape OP point --->  shape
  * Result: A geometry resulting from the application of a translation by the right-hand operand distance to the left-hand operand (geometry, agent, point)    
  * See also: [#rotated_by rotated_by], [#transformed_by transformed_by], 
  {{{  
     self translated_by 45 -> returns the geometry resulting from a 10m translation to the geometry of the agent applying the operator.
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== triangle == 

  * Possible use: 
    * OP(float) --->  shape
  * Result: A triangle geometry which side size is given by the operand.  
  * Comment: the centre of the triangle is by default the location of the current agent in which has been called this operator.
  * Special cases:
    * returns nil if the operand is nil.    
  * See also: [#around around], [#circle circle], [#cone cone], [#line line], [#link link], [#norm norm], [#point point], [#polygon polygon], [#polyline polyline], [#rectangle rectangle], [#square square], 
  {{{  
     triangle(5) -> returns a geometry as a triangle with side_size = 5.
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== triangulate == 

  * Possible use: 
    * OP(shape) --->  list of shapes
  * Result: A list of geometries (triangles) corresponding to the Delaunay triangulation of the operand geometry (geometry, agent, point)
  {{{  
     triangulate(self) -> returns the list of geometries (triangles) corresponding to the Delaunay triangulation of the geometry of the agent applying the operator.
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== truncated_gauss == 

  * Possible use: 
    * OP(point) --->  float
    * OP(list) --->  float
  * Result: A random value from a normally distributed random variable in the interval ]mean - standardDeviation; mean + standardDeviation[.
  * Special cases:
    * when the operand is a point, it is read as {mean, standardDeviation}
    * if the operand is a list, only the two first elements are taken into account as [mean, standardDeviation]
    * when truncated_gauss is called with a list of only one element mean, it will always return 0.0    
  * See also: [#gauss gauss], 
  {{{  
     truncated_gauss ({0, 0.3})  ->  an float between -0.3 and 0.3
     truncated_gauss ([0.5, 0.0])  ->  0.5 (always)
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== undirected == 

  * Possible use: 
    * OP(graph) --->  graph
  * Result: the operand graph becomes an undirected graph.  
  * Comment: the operator alters the operand graph, it does not create a new one.    
  * See also: [#directed directed], 
[#Table_of_Contents Top of the page] 
  	
    
== union == 

  * Possible use: 
    * OP(list) --->  shape
    * OP(species) --->  shape
    * list OP list --->  list
  * Result: returns a new list containing all the elements of both operands without duplicated elements. Elements of this new list are sorted.The geometry resulting from the union of all geometries of agents of the operand-species  
  * Comment: union is only defined with a list as left operand
  * Special cases:
    * if the right-operand is a list of points, geometries or agents, returns the geometry resulting from the union all the geometries
    * if the right operand is nil, union returns a copy of the left operand    
  * See also: [#inter inter], [#+ +], 
  {{{  
     union([geom1, geom2, geom3]) -> a geometry corresponding to union between geom1, geom2 and geom3
     [1,2,3,4,5,6] union [2,4,9] 		--: 	[1,2,3,4,5,6,9]
     [1,2,3,4,5,6] union [0,8] 			--: 	[0,1,2,3,4,5,6,8]
     [1,3,2,4,5,6,8,5,6] union [0,8] 	--: 	[0,1,2,3,4,5,6,8]
     union(species1)  -> returns the geometry resulting from the union of all of the geometries of agents of species species1.
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== unknown == 

  * Possible use: 
    * OP(any) --->  any
  * Result: returns the operand itself
[#Table_of_Contents Top of the page] 
  	
    
== user_input == 

  * Possible use: 
    * OP(java.util.Map<java.lang.String,java.lang.Object>) --->  java.util.Map<java.lang.String,java.lang.Object>
  * Result: asks the user for some values (not defined as parameters)  
  * Comment: This operator takes a map [string::value] as argument, displays a dialog asking the user for these values, and returns the same map with the modified values (if any). The dialog is modal and will interrupt the execution of the simulation until the user has either dismissed or accepted it. It can be used, for instance, in an init section to force the user to input new values instead of relying on the initial values of parameters :
  {{{  
     init {
     	let values <- user_input(["Number" :: 100, "Location" :: {10, 10}]);
     	create node number : int(values at "Number") with: [location:: (point(values at "Location"))];
     }
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== variance == 

  * Possible use: 
    * OP(list) --->  float
  * Result: the variance of the elements of the operand. See <A href="http://en.wikipedia.org/wiki/Variance">Variance</A> for more details.  
  * Comment: The operator casts all the numerical element of the list into float. The elements that are not numerical are discarded.     
  * See also: [#mean mean], [#median median], 
  {{{  
     variance ([4.5, 3.5, 5.5, 7.0]) -> 1.671875	
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== weight_of == 

  * Possible use: 
    * graph OP any --->  float
  * Result: returns the weight of the given edge (right-hand operand) contained in the graph given in right-hand operand.  
  * Comment: In a localized graph, an edge has a weight by default (the distance between both vertices).
  * Special cases:
    * if the left-operand (the graph) is nil, returns nil
    * if the right-hand operand is not an edge of the given graph, weight_of checks whether it is a node of the graph and tries to return its weight
    * if the right-hand operand is neither a node, nor an edge, returns 1.
  {{{  
     let graphFromMap type: graph <-  as_edge_graph([{1,5}::{12,45},{12,45}::{34,56}]);
     graphFromMap source_of(link({1,5}::{12,45}))  --: 41.48493702538308
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== where == 

  * Possible use: 
    * map OP any expression --->  map
    * container OP any expression --->  list
  * Result: a list containing all the elements of the left-hand operand that make the right-hand operand evaluate to true.   
  * Comment: in the right-hand operand, the keyword each can be used to represent, in turn, each of the right-hand operand elements. 
  * Special cases:
    * if the left-hand operand is a list nil, where returns a new empty list    
  * See also: [#first_with first_with], [#last_with last_with], [#where where], 
  {{{  
     [1,2,3,4,5,6,7,8] where (each > 3) 						--: 	[4, 5, 6, 7, 8] 
     g2 where (length(g2 out_edges_of each) = 0 ) 				--: 	[node9, node7, node10, node8, node11]
     (list(node) where (round(node(each).location.x) > 32)   	--:  	[node2, node3]
     [1::2, 3::4, 5::6] where (each.value > 4) 						--: 	
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== with_max_of == 

  * Possible use: 
    * container OP any expression --->  any
  * Result: one of elements of the left-hand operand that maximizes the value of the right-hand operand  
  * Comment: in the right-hand operand, the keyword each can be used to represent, in turn, each of the right-hand operand elements. 
  * Special cases:
    * if the left-hand operand is nil, with_max_of returns the default value of the right-hand operand    
  * See also: [#where where], [#with_min_of with_min_of], 
  {{{  
     [1,2,3,4,5,6,7,8] with_max_of (each ) 						--: 	8
     g2 with_max_of (length(g2 out_edges_of each)  ) 			--: 	node4
     (list(node) with_max_of (round(node(each).location.x))    	--:  	node3
     [1::2, 3::4, 5::6] with_max_of (each) 						--: 	6
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== with_min_of == 

  * Possible use: 
    * container OP any expression --->  any
  * Result: one of elements of the left-hand operand that minimizes the value of the right-hand operand  
  * Comment: in the right-hand operand, the keyword each can be used to represent, in turn, each of the right-hand operand elements. 
  * Special cases:
    * if the left-hand operand is nil, with_max_of returns the default value of the right-hand operand    
  * See also: [#where where], [#with_max_of with_max_of], 
  {{{  
     [1,2,3,4,5,6,7,8] with_min_of (each ) 						--: 	1
     g2 with_min_of (length(g2 out_edges_of each)  ) 			--: 	node11
     (list(node) with_min_of (round(node(each).location.x))    	--:  	node0
     [1::2, 3::4, 5::6] with_min_of (each) 						--: 	2
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== with_optimizer_type == 

  * Possible use: 
    * graph OP string --->  graph
  * Result: changes the shortest path computation method of the griven graph  
  * Comment: the right-hand operand can be "Djikstra", "Bellmann", "Astar" to use the associated algorithm. Note that these methods are dynamic: the path is computed when needed. In contrarily, if the operand is another string, a static method will be used, i.e. all the shortest are previously computed.    
  * See also: [#set_verbose set_verbose], 
  {{{  
     set graphEpidemio <- graphEpidemio with_optimizer_type "static";
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== with_precision == 

  * Possible use: 
    * float OP int --->  float
  * Result: round off the value of left-hand operand to the precision given by the value of right-hand operand    
  * See also: [#round round], 
  {{{  
     12345.78943 with_precision 2 	--:	 12345.79
     123 with_precision 2 	--:	 123.00
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== with_weights == 

  * Possible use: 
    * graph OP map --->  graph
    * graph OP list --->  graph
  * Result: returns the graph (left-hand operand) with weight given in the map (right-hand operand).  
  * Comment: this operand re-initializes the path finder
  * Special cases:
    * if the left-hand operand is a map, the map should contains pairs such as: vertex/edge::double
    * if the right-hand operand is a list, affects the n elements of the list to the n first edges. Note that the ordering of edges may change overtime, which can create some problems...
  {{{  
     graph_from_edges (list(ant) as_map each::one_of (list(ant))) with_weights (list(ant) as_map each::each.food)
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== without_holes == 

  * Possible use: 
    * OP(shape) --->  shape
  * Result: A geometry corresponding to the operand geometry (geometry, agent, point) without its holes
  {{{  
     solid(self) -> returns the geometry corresponding to the geometry of the agent applying the operator without its holes.
   }}} 
  
[#Table_of_Contents Top of the page] 
  	
    
== write == 

  * Possible use: 
    * OP(msi.gama.util.file.IGamaFile) --->  any
  * Result: marks the file so that read and write operations are allowed.  
  * Comment: A file is created by default in read-only mode.    
  * See also: [#file file], [#read read], 
  {{{  
     write(shapefile("../images/point_eau.shp"))   --: returns a file in read-write mode representing "../images/point_eau.shp"
   }}} 
  
[#Table_of_Contents Top of the page] 
  	