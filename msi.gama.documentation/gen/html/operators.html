<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<body bgcolor="#999999">
<A href="#-">-</A>; 
    	<A href="#:">:</A>; 
    	<A href="#::">::</A>; 
    	<A href="#!">!</A>; 
    	<A href="#!=">!=</A>; 
    	<A href="#?">?</A>; 
    	<A href="#/">/</A>; 
    	<A href="#.">.</A>; 
    	<A href="#^">^</A>; 
    	<A href="#*">*</A>; 
    	<A href="#+">+</A>; 
    	<A href="#<">&lt;</A>; 
    	<A href="#<=">&lt;=</A>; 
    	<A href="#<->">&lt;-&gt;</A>; 
    	<A href="#=">=</A>; 
    	<A href="#>">&gt;</A>; 
    	<A href="#>=">&gt;=</A>; 
    	<A href="#abs">abs</A>; 
    	<A href="#accumulate">accumulate</A>; 
    	<A href="#acos">acos</A>; 
    	<A href="#add_point">add_point</A>; 
    	<A href="#agent">agent</A>; 
    	<A href="#agent_closest_to">agent_closest_to</A>; 
    	<A href="#agent_from_geometry">agent_from_geometry</A>; 
    	<A href="#agents_at_distance">agents_at_distance</A>; 
    	<A href="#agents_inside">agents_inside</A>; 
    	<A href="#agents_overlapping">agents_overlapping</A>; 
    	<A href="#among">among</A>; 
    	<A href="#and">and</A>; 
    	<A href="#any_location_in">any_location_in</A>; 
    	<A href="#around">around</A>; 
    	<A href="#as">as</A>; 
    	<A href="#as_4_grid">as_4_grid</A>; 
    	<A href="#as_date">as_date</A>; 
    	<A href="#as_distance_graph">as_distance_graph</A>; 
    	<A href="#as_edge_graph">as_edge_graph</A>; 
    	<A href="#as_grid">as_grid</A>; 
    	<A href="#as_int">as_int</A>; 
    	<A href="#as_intersection_graph">as_intersection_graph</A>; 
    	<A href="#as_map">as_map</A>; 
    	<A href="#as_matrix">as_matrix</A>; 
    	<A href="#as_time">as_time</A>; 
    	<A href="#asin">asin</A>; 
    	<A href="#at">at</A>; 
    	<A href="#at_distance">at_distance</A>; 
    	<A href="#at_location">at_location</A>; 
    	<A href="#atan">atan</A>; 
    	<A href="#binomial">binomial</A>; 
    	<A href="#bool">bool</A>; 
    	<A href="#ceil">ceil</A>; 
    	<A href="#circle">circle</A>; 
    	<A href="#clean">clean</A>; 
    	<A href="#closest_points_with">closest_points_with</A>; 
    	<A href="#closest_to">closest_to</A>; 
    	<A href="#collate">collate</A>; 
    	<A href="#collect">collect</A>; 
    	<A href="#column_at">column_at</A>; 
    	<A href="#columns_list">columns_list</A>; 
    	<A href="#cone">cone</A>; 
    	<A href="#container">container</A>; 
    	<A href="#contains">contains</A>; 
    	<A href="#contains_all">contains_all</A>; 
    	<A href="#contains_any">contains_any</A>; 
    	<A href="#contains_edge">contains_edge</A>; 
    	<A href="#contains_vertex">contains_vertex</A>; 
    	<A href="#convex_hull">convex_hull</A>; 
    	<A href="#copy">copy</A>; 
    	<A href="#copy_between">copy_between</A>; 
    	<A href="#cos">cos</A>; 
    	<A href="#count">count</A>; 
    	<A href="#crosses">crosses</A>; 
    	<A href="#dead">dead</A>; 
    	<A href="#directed">directed</A>; 
    	<A href="#direction_between">direction_between</A>; 
    	<A href="#distance_between">distance_between</A>; 
    	<A href="#distance_to">distance_to</A>; 
    	<A href="#div">div</A>; 
    	<A href="#empty">empty</A>; 
    	<A href="#eval_gaml">eval_gaml</A>; 
    	<A href="#eval_java">eval_java</A>; 
    	<A href="#evaluate_with">evaluate_with</A>; 
    	<A href="#even">even</A>; 
    	<A href="#every">every</A>; 
    	<A href="#exp">exp</A>; 
    	<A href="#fact">fact</A>; 
    	<A href="#farthest_point_to">farthest_point_to</A>; 
    	<A href="#file">file</A>; 
    	<A href="#first">first</A>; 
    	<A href="#first_with">first_with</A>; 
    	<A href="#flip">flip</A>; 
    	<A href="#float">float</A>; 
    	<A href="#floor">floor</A>; 
    	<A href="#folder">folder</A>; 
    	<A href="#frequency_of">frequency_of</A>; 
    	<A href="#gauss">gauss</A>; 
    	<A href="#generate_barabasi_albert">generate_barabasi_albert</A>; 
    	<A href="#generate_watts_strogatz">generate_watts_strogatz</A>; 
    	<A href="#geometric_mean">geometric_mean</A>; 
    	<A href="#geometry">geometry</A>; 
    	<A href="#get">get</A>; 
    	<A href="#graph">graph</A>; 
    	<A href="#grid_at">grid_at</A>; 
    	<A href="#group_by">group_by</A>; 
    	<A href="#harmonic_mean">harmonic_mean</A>; 
    	<A href="#image">image</A>; 
    	<A href="#in">in</A>; 
    	<A href="#in_edges_of">in_edges_of</A>; 
    	<A href="#index_of">index_of</A>; 
    	<A href="#inside">inside</A>; 
    	<A href="#int">int</A>; 
    	<A href="#inter">inter</A>; 
    	<A href="#intersects">intersects</A>; 
    	<A href="#is">is</A>; 
    	<A href="#is_image">is_image</A>; 
    	<A href="#is_number">is_number</A>; 
    	<A href="#is_properties">is_properties</A>; 
    	<A href="#is_shape">is_shape</A>; 
    	<A href="#is_text">is_text</A>; 
    	<A href="#last">last</A>; 
    	<A href="#last_index_of">last_index_of</A>; 
    	<A href="#last_with">last_with</A>; 
    	<A href="#length">length</A>; 
    	<A href="#line">line</A>; 
    	<A href="#link">link</A>; 
    	<A href="#list">list</A>; 
    	<A href="#ln">ln</A>; 
    	<A href="#load_graph_from_dgs">load_graph_from_dgs</A>; 
    	<A href="#load_graph_from_dgs_old">load_graph_from_dgs_old</A>; 
    	<A href="#load_graph_from_dot">load_graph_from_dot</A>; 
    	<A href="#load_graph_from_edge">load_graph_from_edge</A>; 
    	<A href="#load_graph_from_gexf">load_graph_from_gexf</A>; 
    	<A href="#load_graph_from_graphml">load_graph_from_graphml</A>; 
    	<A href="#load_graph_from_lgl">load_graph_from_lgl</A>; 
    	<A href="#load_graph_from_ncol">load_graph_from_ncol</A>; 
    	<A href="#load_graph_from_pajek">load_graph_from_pajek</A>; 
    	<A href="#load_graph_from_tlp">load_graph_from_tlp</A>; 
    	<A href="#map">map</A>; 
    	<A href="#masked_by">masked_by</A>; 
    	<A href="#matrix">matrix</A>; 
    	<A href="#max">max</A>; 
    	<A href="#max_of">max_of</A>; 
    	<A href="#mean">mean</A>; 
    	<A href="#mean_deviation">mean_deviation</A>; 
    	<A href="#median">median</A>; 
    	<A href="#min">min</A>; 
    	<A href="#min_of">min_of</A>; 
    	<A href="#mod">mod</A>; 
    	<A href="#mul">mul</A>; 
    	<A href="#neighbours_at">neighbours_at</A>; 
    	<A href="#neighbours_of">neighbours_of</A>; 
    	<A href="#new_folder">new_folder</A>; 
    	<A href="#norm">norm</A>; 
    	<A href="#of_generic_species">of_generic_species</A>; 
    	<A href="#of_species">of_species</A>; 
    	<A href="#one_of">one_of</A>; 
    	<A href="#or">or</A>; 
    	<A href="#out_edges_of">out_edges_of</A>; 
    	<A href="#overlapping">overlapping</A>; 
    	<A href="#overlaps">overlaps</A>; 
    	<A href="#pair">pair</A>; 
    	<A href="#partially_overlaps">partially_overlaps</A>; 
    	<A href="#path">path</A>; 
    	<A href="#path_between">path_between</A>; 
    	<A href="#path_to">path_to</A>; 
    	<A href="#point">point</A>; 
    	<A href="#points_at">points_at</A>; 
    	<A href="#poisson">poisson</A>; 
    	<A href="#polygon">polygon</A>; 
    	<A href="#predecessors_of">predecessors_of</A>; 
    	<A href="#properties">properties</A>; 
    	<A href="#read">read</A>; 
    	<A href="#rectangle">rectangle</A>; 
    	<A href="#remove_duplicates">remove_duplicates</A>; 
    	<A href="#remove_node_from">remove_node_from</A>; 
    	<A href="#reverse">reverse</A>; 
    	<A href="#rewire_n">rewire_n</A>; 
    	<A href="#rewire_p">rewire_p</A>; 
    	<A href="#rgb">rgb</A>; 
    	<A href="#rnd">rnd</A>; 
    	<A href="#rotated_by">rotated_by</A>; 
    	<A href="#round">round</A>; 
    	<A href="#row_at">row_at</A>; 
    	<A href="#rows_list">rows_list</A>; 
    	<A href="#set_verbose">set_verbose</A>; 
    	<A href="#shapefile">shapefile</A>; 
    	<A href="#shuffle">shuffle</A>; 
    	<A href="#simple_clustering_by_distance">simple_clustering_by_distance</A>; 
    	<A href="#simple_clustering_by_envelope_distance">simple_clustering_by_envelope_distance</A>; 
    	<A href="#simplification">simplification</A>; 
    	<A href="#sin">sin</A>; 
    	<A href="#skeletonize">skeletonize</A>; 
    	<A href="#sort_by">sort_by</A>; 
    	<A href="#source_of">source_of</A>; 
    	<A href="#species">species</A>; 
    	<A href="#split_at">split_at</A>; 
    	<A href="#split_lines">split_lines</A>; 
    	<A href="#split_with">split_with</A>; 
    	<A href="#sqrt">sqrt</A>; 
    	<A href="#square">square</A>; 
    	<A href="#standard_deviation">standard_deviation</A>; 
    	<A href="#string">string</A>; 
    	<A href="#successors_of">successors_of</A>; 
    	<A href="#sum">sum</A>; 
    	<A href="#tan">tan</A>; 
    	<A href="#tanh">tanh</A>; 
    	<A href="#target_of">target_of</A>; 
    	<A href="#text">text</A>; 
    	<A href="#times">times</A>; 
    	<A href="#to_gaml">to_gaml</A>; 
    	<A href="#to_java">to_java</A>; 
    	<A href="#topology">topology</A>; 
    	<A href="#touches">touches</A>; 
    	<A href="#towards">towards</A>; 
    	<A href="#transformed_by">transformed_by</A>; 
    	<A href="#translated_by">translated_by</A>; 
    	<A href="#triangle">triangle</A>; 
    	<A href="#triangulate">triangulate</A>; 
    	<A href="#truncated_gauss">truncated_gauss</A>; 
    	<A href="#undirected">undirected</A>; 
    	<A href="#union">union</A>; 
    	<A href="#unknown">unknown</A>; 
    	<A href="#user_input">user_input</A>; 
    	<A href="#variance">variance</A>; 
    	<A href="#weight_of">weight_of</A>; 
    	<A href="#where">where</A>; 
    	<A href="#with_max_of">with_max_of</A>; 
    	<A href="#with_min_of">with_min_of</A>; 
    	<A href="#with_optimizer_type">with_optimizer_type</A>; 
    	<A href="#with_precision">with_precision</A>; 
    	<A href="#with_weights">with_weights</A>; 
    	<A href="#without_holes">without_holes</A>; 
    	<A href="#write">write</A>; 
    	<br>
<ul>
<li>
<A name="-">-</A>
<br>
<font color="red">a new color resulting from the substraction of the two operands, component by componenta new color resulting from the substraction of each component of the color with the right operandthe difference of the two operandsreturns a new list in which all the elements of the right operand have been removed from the left one<br>- is only defined with a list as left operand</font>
</li>
<li>
<A name=":">:</A>
<br>
<font color="red">
<br>
</font>
</li>
<li>
<A name="::">::</A>
<br>
<font color="red">produces a new pair combining the left and the right operands<br>
</font>
</li>
<li>
<A name="!">!</A>
<br>
<font color="red">opposite boolean value.<br>
</font>
</li>
<li>
<A name="!=">!=</A>
<br>
<font color="red">true if both operands are different, false otherwise<br> this operator will return false if the two operands are identical (i.e., the same object) or equal. Comparisons between nil values are permitted.</font>
</li>
<li>
<A name="?">?</A>
<br>
<font color="red">if the left-hand operand evaluates to true, returns the value of the left-hand operand of the :, otherwise that of the right-hand operand of the :<br>These functional tests can be combined together.</font>
</li>
<li>
<A name="/">/</A>
<br>
<font color="red">a new color resulting from the division of each component of the color by the right operand. The result on each component is then truncated.a new color resulting from the division of each component of the color by the right operanda float, equal to the division of the left-hand operand by the rigth-hand operand.<br>
</font>
</li>
<li>
<A name=".">.</A>
<br>
</li>
<li>
<A name="^">^</A>
<br>
<font color="red">the left-hand operand raised to the power of the right-hand operand.<br>
</font>
</li>
<li>
<A name="*">*</A>
<br>
<font color="red">the product of the two operandsa new color resulting from the product of each component of the color with the right operand<br>
</font>
</li>
<li>
<A name="+">+</A>
<br>
<font color="red">the sum, union or concatenation of the two operands.returns a new list containing all the elements of both operandsa new color resulting from the sum of each component of the color with the right operanda new color resulting from the sum of the two operands, component by component<br>+ is only defined with a list as left operand</font>
</li>
<li>
<A name="<">&lt;</A>
<br>
<font color="red">true if the left-hand operand is less than the right-hand operand, false otherwise.<br>
</font>
</li>
<li>
<A name="<=">&lt;=</A>
<br>
<font color="red">true if the left-hand operand is less or equal than the right-hand operand, false otherwise.<br>
</font>
</li>
<li>
<A name="<->">&lt;-&gt;</A>
<br>
<font color="red">A boolean, equal to true if the left-geometry (or agent/point) is disjoints from the right-geometry (or agent/point).<br>
</font>
</li>
<li>
<A name="=">=</A>
<br>
<font color="red">true if both operands are equal, false otherwise<br>this operator will return true if the two operands are identical (i.e., the same object) or equal. Comparisons between nil values are permitted.</font>
</li>
<li>
<A name=">">&gt;</A>
<br>
<font color="red">true if the left-hand operand is greater than the right-hand operand, false otherwise.<br>
</font>
</li>
<li>
<A name=">=">&gt;=</A>
<br>
<font color="red">true if the left-hand operand is greater or equal than the right-hand operand, false otherwise.<br>
</font>
</li>
<li>
<A name="abs">abs</A>
<br>
<font color="red">the absolute value of the operand (so a positive int or float depending on the type of the operand).<br>
</font>
</li>
<li>
<A name="accumulate">accumulate</A>
<br>
<font color="red">returns a new flat list, in which each element is the evaluation of the right-hand operand. If this evaluation returns a list, the elements of this result are added directly to the list returned<br>accumulate is dedicated to the application of a same computation on each element of a container (and returns a list) In the right-hand operand, the keyword each can be used to represent, in turn, each of the right-hand operand elements. </font>
</li>
<li>
<A name="acos">acos</A>
<br>
<font color="red">the arccos of the operand (which has to be expressed in decimal degrees).<br>
</font>
</li>
<li>
<A name="add_point">add_point</A>
<br>
<font color="red">A geometry resulting from the adding of a right-point (coordinate) to the right-geometry<br>
</font>
</li>
<li>
<A name="agent">agent</A>
<br>
<font color="red">casting of the operand to an agent (if a species name is used, casting to an instance of species name).<br>
</font>
</li>
<li>
<A name="agent_closest_to">agent_closest_to</A>
<br>
<font color="red">A agent, the closest to the operand (casted as a geometry).<br>the distance is computed in the topology of the calling agent (the agent in which this operator is used), with the distance algorithm specific to the topology.</font>
</li>
<li>
<A name="agent_from_geometry">agent_from_geometry</A>
<br>
<font color="red">returns the agent corresponding to given geometry (right-hand operand) in the given path (left-hand operand).<br>
</font>
</li>
<li>
<A name="agents_at_distance">agents_at_distance</A>
<br>
<font color="red">A list of agents situated at a distance &lt;= the right argument.<br>Equivalent to neighbours_at with a left-hand argument equal to 'self'</font>
</li>
<li>
<A name="agents_inside">agents_inside</A>
<br>
<font color="red">A list of agents covered by the operand (casted as a geometry).<br>
</font>
</li>
<li>
<A name="agents_overlapping">agents_overlapping</A>
<br>
<font color="red">A list of agents overlapping the operand (casted as a geometry).<br>
</font>
</li>
<li>
<A name="among">among</A>
<br>
<font color="red">a list of length the value of the left-hand operand, containing random elements from the right-hand operand<br>
</font>
</li>
<li>
<A name="and">and</A>
<br>
<font color="red">a bool value, equal to the logical and between the left-hand operand and the rigth-hand operand.<br>both operands are always casted to bool before applying the operator. Thus, an expression like (1 and 0) is accepted and returns false.</font>
</li>
<li>
<A name="any_location_in">any_location_in</A>
<br>
<font color="red">A point inside (or touching) the operand-geometry.<br>
</font>
</li>
<li>
<A name="around">around</A>
<br>
<font color="red">A geometry resulting from the difference between a buffer around the right-operand casted in geometry at a distance left-operand (right-operand buffer left-operand) and the right-operand casted as geometry.<br>
</font>
</li>
<li>
<A name="as">as</A>
<br>
<font color="red">casting of the left-hand operand to a species.<br>
</font>
</li>
<li>
<A name="as_4_grid">as_4_grid</A>
<br>
<font color="red">A matrix of square geometries (grid with 4-neighbourhood) with dimension given by the rigth-hand operand ({nb_cols, nb_lines}) corresponding to the square tessellation of the left-hand operand geometry (geometry, agent)<br>
</font>
</li>
<li>
<A name="as_date">as_date</A>
<br>
</li>
<li>
<A name="as_distance_graph">as_distance_graph</A>
<br>
<font color="red">creates a graph from a list of vertices (left-hand operand). An edge is created between each pair of vertices close enough (less than a distance, right-hand operand).<br>as_distance_graph is more efficient for a list of points than as_intersection_graph.</font>
</li>
<li>
<A name="as_edge_graph">as_edge_graph</A>
<br>
<font color="red">creates a graph from the list/map of edges given as operand<br>
</font>
</li>
<li>
<A name="as_grid">as_grid</A>
<br>
<font color="red">A matrix of square geometries (grid with 8-neighbourhood) with dimension given by the rigth-hand operand ({nb_cols, nb_lines}) corresponding to the square tessellation of the left-hand operand geometry (geometry, agent)<br>
</font>
</li>
<li>
<A name="as_int">as_int</A>
<br>
<font color="red">parses the string argument as a signed integer in the radix specified by the second argument.<br>
</font>
</li>
<li>
<A name="as_intersection_graph">as_intersection_graph</A>
<br>
<font color="red">creates a graph from a list of vertices (left-hand operand). An edge is created between each pair of vertices with an intersection (with a given tolerance).<br>as_intersection_graph is more efficient for a list of geometries (but less accurate) than as_distance_graph.</font>
</li>
<li>
<A name="as_map">as_map</A>
<br>
<font color="red">produces a new map from the evaluation of the right-hand operand for each element of the left-hand operand<br>the right-hand operand should be pair or a map.</font>
</li>
<li>
<A name="as_matrix">as_matrix</A>
<br>
<font color="red">casts the left operand into a matrix with right operand as preferrenced size<br>This operator is very useful to cast a file containing raster data into a matrix.Note that both components of the right operand point should be positive, otherwise an exception is raised.The operator as_matrix creates a matrix of preferred size. It fills in it with elements of the left operand until the matrix is full If the size is to short, some elements will be omitted. Matrix remaining elements will be filled in by nil.</font>
</li>
<li>
<A name="as_time">as_time</A>
<br>
</li>
<li>
<A name="asin">asin</A>
<br>
<font color="red">the arcsin of the operand (which has to be expressed in decimal degrees).<br>
</font>
</li>
<li>
<A name="at">at</A>
<br>
<font color="red">the element at the right operand index of the container<br>The first element of the container is located at the index 0. In addition, if the user tries to get the element at an index higher or equals than the length of the container, he will get an IndexOutOfBoundException.The at operator behavior depends on the nature of the operand</font>
</li>
<li>
<A name="at_distance">at_distance</A>
<br>
<font color="red">A list of agents among the left-operand list that are located at a distance &lt;= the right operand from the caller agent (in its topology)<br>
</font>
</li>
<li>
<A name="at_location">at_location</A>
<br>
<font color="red">A geometry resulting from the tran of a translation to the right-hand operand point of the left-hand operand (geometry, agent, point)<br>
</font>
</li>
<li>
<A name="atan">atan</A>
<br>
<font color="red">the arctan of the operand (which has to be expressed in decimal degrees).<br>
</font>
</li>
<li>
<A name="binomial">binomial</A>
<br>
<font color="red">A value from a random variable following a binomial distribution. The operand {n,p} represents the number of experiments n and the success probability p.<br>The binomial distribution is the discrete probability distribution of the number of successes in a sequence of n independent yes/no experiments, each of which yields success with probability p, cf. Binomial distribution on Wikipedia.</font>
</li>
<li>
<A name="bool">bool</A>
<br>
<font color="red">casting of the operand to a boolean value.<br>
</font>
</li>
<li>
<A name="ceil">ceil</A>
<br>
<font color="red">maps the operand to the smallest following integer.<br>More precisely, ceiling(x) is the smallest integer not less than x.</font>
</li>
<li>
<A name="circle">circle</A>
<br>
<font color="red">A circle geometry which radius is equal to the operand.<br>the centre of the circle is by default the location of the current agent in which has been called this operator.</font>
</li>
<li>
<A name="clean">clean</A>
<br>
<font color="red">A geometry corresponding to the cleaning of the operand (geometry, agent, point)<br>The cleaning corresponds to a buffer with a distance of 0.0</font>
</li>
<li>
<A name="closest_points_with">closest_points_with</A>
<br>
<font color="red">A list of two closest points between the two geometries.<br>
</font>
</li>
<li>
<A name="closest_to">closest_to</A>
<br>
<font color="red">An agent among the left-operand list, the closest to the operand (casted as a geometry).<br>the distance is computed in the topology of the calling agent (the agent in which this operator is used), with the distance algorithm specific to the topology.</font>
</li>
<li>
<A name="collate">collate</A>
<br>
<font color="red">a new list containing interleaved elements of the operand<br>the operand should be a list of lists of elements. The result is a list of elements. </font>
</li>
<li>
<A name="collect">collect</A>
<br>
<font color="red">returns a new list, in which each element is the evaluation of the right-hand operand.<br>collect is very similar to accumulate except. Nevertheless if the evaluation of the right-hand operand produces a list,the returned list is a list of list of elements. In contrarily, the list produces by accumulate is only a list of elements (all the lists) produced are concaneted. In addition, collect can be applied to any container.</font>
</li>
<li>
<A name="column_at">column_at</A>
<br>
</li>
<li>
<A name="columns_list">columns_list</A>
<br>
</li>
<li>
<A name="cone">cone</A>
<br>
<font color="red">A cone geometry which min and max angles are given by the operands.<br>the centre of the cone is by default the location of the current agent in which has been called this operator.</font>
</li>
<li>
<A name="container">container</A>
<br>
<font color="red">casting of the operand to a container<br>
</font>
</li>
<li>
<A name="contains">contains</A>
<br>
<font color="red">true, if the container contains the right operand, false otherwise<br>the contains operator behavior depends on the nature of the operand</font>
</li>
<li>
<A name="contains_all">contains_all</A>
<br>
<font color="red">true if the left operand contains all the elements of the right operand, false otherwise<br>the definition of contains depends on the container</font>
</li>
<li>
<A name="contains_any">contains_any</A>
<br>
<font color="red">true if the left operand contains one of the elements of the right operand, false otherwise<br>the definition of contains depends on the container</font>
</li>
<li>
<A name="contains_edge">contains_edge</A>
<br>
<font color="red">returns true if the graph(left-hand operand) contains the given edge (righ-hand operand), false otherwise<br>
</font>
</li>
<li>
<A name="contains_vertex">contains_vertex</A>
<br>
<font color="red">returns true if the graph(left-hand operand) contains the given vertex (righ-hand operand), false otherwise<br>
</font>
</li>
<li>
<A name="convex_hull">convex_hull</A>
<br>
<font color="red">A geometry corresponding to the convex hull of the operand.<br>
</font>
</li>
<li>
<A name="copy">copy</A>
<br>
</li>
<li>
<A name="copy_between">copy_between</A>
<br>
<font color="red">returns a copy of a sublist of the left operand between a begin index (x of the right operand point) and a end index (y of the right operand point<br>copy_between can only be used on list (and string)</font>
</li>
<li>
<A name="cos">cos</A>
<br>
<font color="red">the cosinus of the operand (in decimal degrees).<br>
</font>
</li>
<li>
<A name="count">count</A>
<br>
<font color="red">returns an int, equal to the number of elements of the left-hand operand that make the right-hand operand evaluate to true.<br>in the right-hand operand, the keyword each can be used to represent, in turn, each of the elements.</font>
</li>
<li>
<A name="crosses">crosses</A>
<br>
<font color="red">A boolean, equal to true if the left-geometry (or agent/point) crosses the right-geometry (or agent/point).<br>
</font>
</li>
<li>
<A name="dead">dead</A>
<br>
</li>
<li>
<A name="directed">directed</A>
<br>
<font color="red">the operand graph becomes a directed graph.<br>the operator alters the operand graph, it does not create a new one.</font>
</li>
<li>
<A name="direction_between">direction_between</A>
<br>
<font color="red">A direction (in degree) between a list of two geometries (geometries, agents, points) considering a topology.<br>
</font>
</li>
<li>
<A name="distance_between">distance_between</A>
<br>
<font color="red">A distance between a list of geometries (geometries, agents, points) considering a topology.<br>
</font>
</li>
<li>
<A name="distance_to">distance_to</A>
<br>
<font color="red">A distance between two geometries (geometries, agents or points) considering the topology of the agent applying the operator.<br>
</font>
</li>
<li>
<A name="div">div</A>
<br>
<font color="red">an int, equal to the truncation of the division of the left-hand operand by the rigth-hand operand.<br>
</font>
</li>
<li>
<A name="empty">empty</A>
<br>
<font color="red">true if the operand is empty, false otherwise.<br>the empty operator behavior depends on the nature of the operand</font>
</li>
<li>
<A name="eval_gaml">eval_gaml</A>
<br>
</li>
<li>
<A name="eval_java">eval_java</A>
<br>
</li>
<li>
<A name="evaluate_with">evaluate_with</A>
<br>
</li>
<li>
<A name="even">even</A>
<br>
<font color="red">true if the operand is even and false if it is odd.<br>
</font>
</li>
<li>
<A name="every">every</A>
<br>
</li>
<li>
<A name="exp">exp</A>
<br>
<font color="red">returns Euler's number e raised to the power of the operand.<br>
</font>
</li>
<li>
<A name="fact">fact</A>
<br>
<font color="red">the factorial of the operand.<br>
</font>
</li>
<li>
<A name="farthest_point_to">farthest_point_to</A>
<br>
<font color="red">the farthest point of the left-operand to the left-point.<br>
</font>
</li>
<li>
<A name="file">file</A>
<br>
<font color="red">opens a file in read only mode, creates a GAML file object, and tries to determine and store the file content in the contents attribute.<br>The file should have a supported extension, see file type deifnition for supported file extensions.</font>
</li>
<li>
<A name="first">first</A>
<br>
<font color="red">the first element of the operand<br>the first operator behavior depends on the nature of the operand</font>
</li>
<li>
<A name="first_with">first_with</A>
<br>
<font color="red">the first element of the left-hand operand that makes the right-hand operand evaluate to true.<br>in the right-hand operand, the keyword each can be used to represent, in turn, each of the right-hand operand elements. </font>
</li>
<li>
<A name="flip">flip</A>
<br>
<font color="red">true or false given the probability represented by the operand<br>
</font>
</li>
<li>
<A name="float">float</A>
<br>
<font color="red">casting of the operand to a floating point value.<br>
</font>
</li>
<li>
<A name="floor">floor</A>
<br>
<font color="red">maps the operand to the largest previous following integer.<br>More precisely, floor(x) is the largest integer not greater than x.</font>
</li>
<li>
<A name="folder">folder</A>
<br>
<font color="red">opens an existing repository<br>
</font>
</li>
<li>
<A name="frequency_of">frequency_of</A>
<br>
<font color="red">Returns a map with keys equal to the application of the right-hand argument (like collect) and values equal to the frequency of this key (i.e. how many times it has been obtained)<br>
</font>
</li>
<li>
<A name="gauss">gauss</A>
<br>
<font color="red">A value from a normally distributed random variable with expected value (mean) and variance (standardDeviation). The probability density function of such a variable is a Gaussian.<br>
</font>
</li>
<li>
<A name="generate_barabasi_albert">generate_barabasi_albert</A>
<br>
<font color="red">returns a random scale-free network (following Barabasi&ndash;Albert (BA) model).<br>The Barabasi&ndash;Albert (BA) model is an algorithm for generating random scale-free networks using a preferential attachment mechanism. A scale-free network is a network whose degree distribution follows a power law, at least asymptotically.Such networks are widely observed in natural and human-made systems, including the Internet, the world wide web, citation networks, and some social networks. [From Wikipedia article]The map operand should includes following elements:</font>
</li>
<li>
<A name="generate_watts_strogatz">generate_watts_strogatz</A>
<br>
<font color="red">returns a random small-world network (following Watts-Strogatz model).<br>The Watts-Strogatz model is a random graph generation model that produces graphs with small-world properties, including short average path lengths and high clustering.A small-world network is a type of graph in which most nodes are not neighbors of one another, but most nodes can be reached from every other by a small number of hops or steps. [From Wikipedia article]The map operand should includes following elements:</font>
</li>
<li>
<A name="geometric_mean">geometric_mean</A>
<br>
<font color="red">the geometric mean of the elements of the operand. See &lt;A href="http://en.wikipedia.org/wiki/Geometric_mean"&gt;Geometric_mean&lt;/A&gt; for more details.<br>The operator casts all the numerical element of the list into float. The elements that are not numerical are discarded.</font>
</li>
<li>
<A name="geometry">geometry</A>
<br>
<font color="red">casts the operand into a geometry<br>
</font>
</li>
<li>
<A name="get">get</A>
<br>
</li>
<li>
<A name="graph">graph</A>
<br>
<font color="red">casting of the operand to a graph.<br>
</font>
</li>
<li>
<A name="grid_at">grid_at</A>
<br>
<font color="red">
<br>
</font>
</li>
<li>
<A name="group_by">group_by</A>
<br>
<font color="red">a map, where the keys take the possible values of the right-hand operand and the map values are the list of elements of the left-hand operand associated to the key value<br>in the right-hand operand, the keyword each can be used to represent, in turn, each of the right-hand operand elements. </font>
</li>
<li>
<A name="harmonic_mean">harmonic_mean</A>
<br>
<font color="red">the harmonic mean of the elements of the operand. See &lt;A href="http://en.wikipedia.org/wiki/Harmonic_mean"&gt;Harmonic_mean&lt;/A&gt; for more details.<br>The operator casts all the numerical element of the list into float. The elements that are not numerical are discarded.</font>
</li>
<li>
<A name="image">image</A>
<br>
<font color="red">opens a file that is a kind of image.<br>The file should have an image extension, cf. file type deifnition for supported file extensions.</font>
</li>
<li>
<A name="in">in</A>
<br>
<font color="red">true if the right operand contains the left operand, false otherwise<br>the definition of in depends on the container</font>
</li>
<li>
<A name="in_edges_of">in_edges_of</A>
<br>
<font color="red">returns the list of the in-edges of a vertex (right-hand operand) in the graph given as left-hand operand.<br>
</font>
</li>
<li>
<A name="index_of">index_of</A>
<br>
<font color="red">the index of the first occurence of the right operand in the left operand container<br>index_of is only defined for list, map and matrix. The definition of index_of and the type of the index depend on the container</font>
</li>
<li>
<A name="inside">inside</A>
<br>
<font color="red">A list of agents among the left-operand list, covered by the operand (casted as a geometry).<br>
</font>
</li>
<li>
<A name="int">int</A>
<br>
<font color="red">casting of the operand to an integer value.<br>
</font>
</li>
<li>
<A name="inter">inter</A>
<br>
<font color="red">the intersection of the two operandsA geometry resulting from the intersection between the two geometries<br>both containers are transformed into sets (so without duplicated element, cf. remove_deplicates operator) before the set intersection is computed.</font>
</li>
<li>
<A name="intersects">intersects</A>
<br>
<font color="red">A boolean, equal to true if the left-geometry (or agent/point) intersects the right-geometry (or agent/point).<br>
</font>
</li>
<li>
<A name="is">is</A>
<br>
</li>
<li>
<A name="is_image">is_image</A>
<br>
<font color="red">the operator tests whether the operand represents the name of a supported image file<br>cf. file type definition for supported (espacially image) file extensions.</font>
</li>
<li>
<A name="is_number">is_number</A>
<br>
</li>
<li>
<A name="is_properties">is_properties</A>
<br>
<font color="red">the operator tests whether the operand represents the name of a supported properties file<br>cf. file type definition for supported (espacially image) file extensions.</font>
</li>
<li>
<A name="is_shape">is_shape</A>
<br>
<font color="red">the operator tests whether the operand represents the name of a supported shapefile<br>cf. file type definition for supported (espacially image) file extensions.</font>
</li>
<li>
<A name="is_text">is_text</A>
<br>
<font color="red">the operator tests whether the operand represents the name of a supported text file<br>cf. file type definition for supported (espacially image) file extensions.</font>
</li>
<li>
<A name="last">last</A>
<br>
<font color="red">the last element of the operand<br>the last operator behavior depends on the nature of the operand</font>
</li>
<li>
<A name="last_index_of">last_index_of</A>
<br>
<font color="red">the index of the last occurence of the right operand in the left operand container<br>last_index_of is only defined for list, map and matrix. The definition of last_index_of and the type of the index depend on the container</font>
</li>
<li>
<A name="last_with">last_with</A>
<br>
<font color="red">the last element of the left-hand operand that makes the right-hand operand evaluate to true.<br>in the right-hand operand, the keyword each can be used to represent, in turn, each of the right-hand operand elements. </font>
</li>
<li>
<A name="length">length</A>
<br>
<font color="red">the number of elements contained in the operand<br>the length operator behavior depends on the nature of the operand</font>
</li>
<li>
<A name="line">line</A>
<br>
<font color="red">A polyline geometry from the given list of points.<br>
</font>
</li>
<li>
<A name="link">link</A>
<br>
<font color="red">A link between the 2 elements of the pair.<br>The geometry of the link is the intersection of the two geometries when they intersect, and a line between their centroids when they do not.</font>
</li>
<li>
<A name="list">list</A>
<br>
<font color="red">transforms the operand into a list<br>list always tries to cast the operand except if it is an int, a bool or a float; to create a list, instead, containing the operand (including another list), use the + operator on an empty list (like [] + 'abc').</font>
</li>
<li>
<A name="ln">ln</A>
<br>
<font color="red">returns the natural logarithm (base e) of the operand.<br>
</font>
</li>
<li>
<A name="load_graph_from_dgs">load_graph_from_dgs</A>
<br>
<font color="red">returns a graph loaded from a given file following DGS graph file format versions 1 and 2<br>similar to load_graph_from_dgs_old</font>
</li>
<li>
<A name="load_graph_from_dgs_old">load_graph_from_dgs_old</A>
<br>
<font color="red">returns a graph loaded from a given file following DGS file format (version 3).<br>DGS is a file format allowing to store graphs and dynamic graphs in a textual human readable way, yet with a small size allowing to store large graphs. Graph dynamics is defined using events like adding, deleting or changing a node or edge. With DGS, graphs will therefore be seen as stream of such events. [From GraphStream related page: http://graphstream-project.org/]The map operand should includes following elements:</font>
</li>
<li>
<A name="load_graph_from_dot">load_graph_from_dot</A>
<br>
<font color="red">returns a graph loaded from a given file following DOT file format.<br>DOT is a plain text graph description language. It is a simple way of describing graphs that both humans and computer programs can use. See: http://en.wikipedia.org/wiki/DOT_language for more details.The map operand should includes following elements:</font>
</li>
<li>
<A name="load_graph_from_edge">load_graph_from_edge</A>
<br>
<font color="red">returns a graph loaded from a given file following Edge file format.<br>This format is a simple text file with numeric vertex ids defining the edges. The map operand should includes following elements:</font>
</li>
<li>
<A name="load_graph_from_gexf">load_graph_from_gexf</A>
<br>
<font color="red">returns a graph loaded from a given file following GEXF file format.<br>GEXF (Graph Exchange XML Format) is a language for describing complex networks structures, their associated data and dynamics. Started in 2007 at Gephi project by different actors, deeply involved in graph exchange issues, the gexf specifications are mature enough to claim being both extensible and open, and suitable for real specific applications. See: http://gexf.net/format/ for more details.The map operand should includes following elements:</font>
</li>
<li>
<A name="load_graph_from_graphml">load_graph_from_graphml</A>
<br>
<font color="red">returns a graph loaded from a given file following GEXF file format.<br>GraphML is a comprehensive and easy-to-use file format for graphs based on XML.  See: http://graphml.graphdrawing.org/ for more details.The map operand should includes following elements:</font>
</li>
<li>
<A name="load_graph_from_lgl">load_graph_from_lgl</A>
<br>
<font color="red">returns a graph loaded from a given file following LGL file format.<br>LGL is a compendium of applications for making the visualization of large networks and trees tractable. See: http://lgl.sourceforge.net/ for more details.The map operand should includes following elements:</font>
</li>
<li>
<A name="load_graph_from_ncol">load_graph_from_ncol</A>
<br>
<font color="red">returns a graph loaded from a given file following ncol file format.<br>This format is used by the Large Graph Layout progra. It is simply a symbolic weighted edge list. It is a simple text file with one edge per line. An edge is defined by two symbolic vertex names separated by whitespace. (The symbolic vertex names themselves cannot contain whitespace.) They might followed by an optional number, this will be the weight of the edge. See: http://bioinformatics.icmb.utexas.edu/lgl for more details.The map operand should includes following elements:</font>
</li>
<li>
<A name="load_graph_from_pajek">load_graph_from_pajek</A>
<br>
<font color="red">returns a graph loaded from a given file following Pajek file format.<br>Pajek (Slovene word for Spider) is a program, for Windows, for analysis and visualization of large networks. See: http://pajek.imfm.si/doku.php?id=pajek for more details.The map operand should includes following elements:</font>
</li>
<li>
<A name="load_graph_from_tlp">load_graph_from_tlp</A>
<br>
<font color="red">returns a graph loaded from a given file following TLP file format.<br>TLP is the Tulip software graph format.  See: http://tulip.labri.fr/TulipDrupal/?q=tlp-file-format for more details.The map operand should includes following elements:</font>
</li>
<li>
<A name="map">map</A>
<br>
<font color="red">casting of the operand to a map.<br>
</font>
</li>
<li>
<A name="masked_by">masked_by</A>
<br>
<font color="red">A geometry representing the part of the right operand visible from the point of view of the agent using the operator while considering the obstacles defined by the left operand<br>
</font>
</li>
<li>
<A name="matrix">matrix</A>
<br>
<font color="red">casts the operand into a matrix<br>
</font>
</li>
<li>
<A name="max">max</A>
<br>
<font color="red">the maximum element found in the operand<br>the max operator behavior depends on the nature of the operand</font>
</li>
<li>
<A name="max_of">max_of</A>
<br>
<font color="red">the maximum value of the right-hand expression evaluated on each of the elements of the left-hand operand<br>in the right-hand operand, the keyword each can be used to represent, in turn, each of the right-hand operand elements. </font>
</li>
<li>
<A name="mean">mean</A>
<br>
<font color="red">the mean of all the elements of the operand<br>the elements of the operand are summed (see sum for more details about the sum of container elements ) and then the sum value is divided by the number of elements.</font>
</li>
<li>
<A name="mean_deviation">mean_deviation</A>
<br>
<font color="red">the deviation from the mean of all the elements of the operand. See &lt;A href= "http://en.wikipedia.org/wiki/Absolute_deviation" &gt;Mean_deviation&lt;/A&gt; for more details.<br>The operator casts all the numerical element of the list into float. The elements that are not numerical are discarded.</font>
</li>
<li>
<A name="median">median</A>
<br>
<font color="red">the median of all the elements of the operand.<br>The operator casts all the numerical element of the list into float. The elements that are not numerical are discarded.</font>
</li>
<li>
<A name="min">min</A>
<br>
<font color="red">the minimum element found in the operand.<br>the min operator behavior depends on the nature of the operand</font>
</li>
<li>
<A name="min_of">min_of</A>
<br>
<font color="red">the minimum value of the right-hand expression evaluated on each of the elements of the left-hand operand<br>in the right-hand operand, the keyword each can be used to represent, in turn, each of the right-hand operand elements. </font>
</li>
<li>
<A name="mod">mod</A>
<br>
<font color="red">an int, equal to the remainder of the integer division of the left-hand operand by the rigth-hand operand.<br>
</font>
</li>
<li>
<A name="mul">mul</A>
<br>
<font color="red">the product of all the elements of the operand<br>the mul operator behavior depends on the nature of the operand</font>
</li>
<li>
<A name="neighbours_at">neighbours_at</A>
<br>
<font color="red">a list, containing all the agents located at a distance inferior or equal to the right-hand operand to the left-hand operand (geometry, agent, point).<br>The topology used to compute the neighbourhood  is the one of the left-operand if this one is an agent; otherwise the one of the agent applying the operator.</font>
</li>
<li>
<A name="neighbours_of">neighbours_of</A>
<br>
<font color="red">a list, containing all the agents located at a distance inferior or equal to 1 to the right-hand operand agent considering the left-hand operand topology.returns the list of neighbours of the given vertex (right-hand operand) in the given graph (left-hand operand)<br>
</font>
</li>
<li>
<A name="new_folder">new_folder</A>
<br>
<font color="red">opens an existing repository or create a new folder if it does not exist.<br>
</font>
</li>
<li>
<A name="norm">norm</A>
<br>
<font color="red">the norm of the vector with the coordinnates of the point operand.<br>
</font>
</li>
<li>
<A name="of_generic_species">of_generic_species</A>
<br>
<font color="red">a list, containing the agents of the left-hand operand whose species is that denoted by the right-hand operand and whose species extends the right-hand operand species <br>
</font>
</li>
<li>
<A name="of_species">of_species</A>
<br>
<font color="red">a list, containing the agents of the left-hand operand whose species is that denoted by the right-hand operand.The expression agents of_species (species self) is equivalent to agents where (species each = species self); however, the advantage of using the first syntax is that the resulting list is correctly typed with the right species, whereas, in the second syntax, the parser cannot determine the species of the agents within the list (resulting in the need to cast it explicitely if it is to be used in an ask statement, for instance).<br>
</font>
</li>
<li>
<A name="one_of">one_of</A>
<br>
<font color="red">a random element from the listone of the values stored in this container using GAMA.getRandom()<br>the one_of operator behavior depends on the nature of the operand</font>
</li>
<li>
<A name="or">or</A>
<br>
<font color="red">a bool value, equal to the logical or between the left-hand operand and the rigth-hand operand.<br>both operands are always casted to bool before applying the operator. Thus, an expression like 1 or 0 is accepted and returns true.</font>
</li>
<li>
<A name="out_edges_of">out_edges_of</A>
<br>
<font color="red">returns the list of the out-edges of a vertex (right-hand operand) in the graph given as left-hand operand.<br>
</font>
</li>
<li>
<A name="overlapping">overlapping</A>
<br>
<font color="red">A list of agents a mong the left-operand list, overlapping the operand (casted as a geometry).<br>
</font>
</li>
<li>
<A name="overlaps">overlaps</A>
<br>
<font color="red">A boolean, equal to true if the left-geometry (or agent/point) overlaps the right-geometry (or agent/point).<br>
</font>
</li>
<li>
<A name="pair">pair</A>
<br>
<font color="red">casting of the operand to a pair value.<br>
</font>
</li>
<li>
<A name="partially_overlaps">partially_overlaps</A>
<br>
<font color="red">A boolean, equal to true if the left-geometry (or agent/point) partially overlaps the right-geometry (or agent/point).<br>if one geometry operand fully covers the other geometry operand, returns false (contrarily to the overlaps operator).</font>
</li>
<li>
<A name="path">path</A>
<br>
<font color="red">casting of the operand to a path<br>
</font>
</li>
<li>
<A name="path_between">path_between</A>
<br>
<font color="red">A path between a list of two geometries (geometries, agents or points) considering a topology.<br>
</font>
</li>
<li>
<A name="path_to">path_to</A>
<br>
<font color="red">A path between two geometries (geometries, agents or points) considering the topology of the agent applying the operator.<br>
</font>
</li>
<li>
<A name="point">point</A>
<br>
<font color="red">casting of the operand to a point value.<br>
</font>
</li>
<li>
<A name="points_at">points_at</A>
<br>
<font color="red">A list of left-operand number of points located at a the right-operand distance to the agent location.<br>
</font>
</li>
<li>
<A name="poisson">poisson</A>
<br>
<font color="red">A value from a random variable following a Poisson distribution (with the positive expected number of occurence lambda as operand).<br>The Poisson distribution is a discrete probability distribution that expresses the probability of a given number of events occurring in a fixed interval of time and/or space if these events occur with a known average rate and independently of the time since the last event, cf. Poisson distribution on Wikipedia.</font>
</li>
<li>
<A name="polygon">polygon</A>
<br>
<font color="red">A polygon geometry from the given list of points.<br>
</font>
</li>
<li>
<A name="predecessors_of">predecessors_of</A>
<br>
<font color="red">returns the list of predecessors (i.e. sources of in edges) of the given vertex (right-hand operand) in the given graph (left-hand operand)<br>
</font>
</li>
<li>
<A name="properties">properties</A>
<br>
<font color="red">opens a file that is a kind of properties.<br>The file should have a properties extension, cf. type file definition for supported file extensions.</font>
</li>
<li>
<A name="read">read</A>
<br>
<font color="red">marks the file so that only read operations are allowed.<br>A file is created by default in read-only mode. The operator write can change the mode.</font>
</li>
<li>
<A name="rectangle">rectangle</A>
<br>
<font color="red">A rectangle geometry which side sizes are given by the operands.<br>the centre of the rectangle is by default the location of the current agent in which has been called this operator.</font>
</li>
<li>
<A name="remove_duplicates">remove_duplicates</A>
<br>
<font color="red">produces a set from the elements of the operand (i.e. a list without duplicated elements)<br>
</font>
</li>
<li>
<A name="remove_node_from">remove_node_from</A>
<br>
</li>
<li>
<A name="reverse">reverse</A>
<br>
<font color="red">the operand elements in the reversed order in a copy of the operand.<br>the reverse operator behavior depends on the nature of the operand</font>
</li>
<li>
<A name="rewire_n">rewire_n</A>
<br>
</li>
<li>
<A name="rewire_p">rewire_p</A>
<br>
</li>
<li>
<A name="rgb">rgb</A>
<br>
<font color="red">casting of the operand to a rgb color.<br>
</font>
</li>
<li>
<A name="rnd">rnd</A>
<br>
<font color="red">a random integer in the interval [0, operand]<br>to obtain a probability between 0 and 1, use the expression (rnd n) / n, where n is used to indicate the precision</font>
</li>
<li>
<A name="rotated_by">rotated_by</A>
<br>
<font color="red">A geometry resulting from the application of a rotation by the right-hand operand angle (degree) to the left-hand operand (geometry, agent, point)<br>the right-hand operand can be a float or a int</font>
</li>
<li>
<A name="round">round</A>
<br>
<font color="red">the rounded value of the operand.<br>
</font>
</li>
<li>
<A name="row_at">row_at</A>
<br>
</li>
<li>
<A name="rows_list">rows_list</A>
<br>
</li>
<li>
<A name="set_verbose">set_verbose</A>
<br>
</li>
<li>
<A name="shapefile">shapefile</A>
<br>
<font color="red">opens a file that a is a kind of shapefile.<br>The file should have a shapefile extension, cf. file type definition for supported file extensions.</font>
</li>
<li>
<A name="shuffle">shuffle</A>
<br>
<font color="red">The elements of the operand in random order.<br>
</font>
</li>
<li>
<A name="simple_clustering_by_distance">simple_clustering_by_distance</A>
<br>
<font color="red">A list of agent groups clustered by distance considering a distance min between two groups.<br>use of hierarchical clustering with Minimum for linkage criterion between two groups of agents.</font>
</li>
<li>
<A name="simple_clustering_by_envelope_distance">simple_clustering_by_envelope_distance</A>
<br>
<font color="red">A list of agent groups clustered by distance (considering the agent envelop) considering a distance min between two groups.<br>use of hierarchical clustering with Minimum for linkage criterion between two groups of agents.</font>
</li>
<li>
<A name="simplification">simplification</A>
<br>
<font color="red">A geometry corresponding to the simplification of the operand (geometry, agent, point) considering a tolerance distance.<br>The algorithm used for the simplification is Douglas-Peucker</font>
</li>
<li>
<A name="sin">sin</A>
<br>
<font color="red">the sinus of the operand (in decimal degrees).<br>
</font>
</li>
<li>
<A name="skeletonize">skeletonize</A>
<br>
<font color="red">A list of geometries (polylines) corresponding to the skeleton of the operand geometry (geometry, agent)<br>
</font>
</li>
<li>
<A name="sort_by">sort_by</A>
<br>
<font color="red">a list, containing the elements of the left-hand operand sorted in ascending order by the value of the right-hand operand when it is evaluated on them. <br>the left-hand operand is casted to a list before applying the operator. In the right-hand operand, the keyword each can be used to represent, in turn, each of the elements.</font>
</li>
<li>
<A name="source_of">source_of</A>
<br>
<font color="red">returns the source of the edge (right-hand operand) contained in the graph given in left-hand operand.<br>
</font>
</li>
<li>
<A name="species">species</A>
<br>
<font color="red">casting of the operand to a species.<br>
</font>
</li>
<li>
<A name="split_at">split_at</A>
<br>
<font color="red">The two part of the left-operand lines split at the given right-operand point<br>
</font>
</li>
<li>
<A name="split_lines">split_lines</A>
<br>
<font color="red">A list of geometries resulting after cutting the lines at their intersections.<br>
</font>
</li>
<li>
<A name="split_with">split_with</A>
<br>
</li>
<li>
<A name="sqrt">sqrt</A>
<br>
<font color="red">returns the square root of the operand.<br>
</font>
</li>
<li>
<A name="square">square</A>
<br>
<font color="red">A square geometry which side size is equal to the operand.<br>the centre of the square is by default the location of the current agent in which has been called this operator.</font>
</li>
<li>
<A name="standard_deviation">standard_deviation</A>
<br>
<font color="red">the standard deviation on the elements of the operand. See &lt;A href="http://en.wikipedia.org/wiki/Standard_deviation"&gt;Standard_deviation&lt;/A&gt; for more details.<br>The operator casts all the numerical element of the list into float. The elements that are not numerical are discarded.</font>
</li>
<li>
<A name="string">string</A>
<br>
<font color="red">casting of the operand to a string.<br>
</font>
</li>
<li>
<A name="successors_of">successors_of</A>
<br>
<font color="red">returns the list of successors (i.e. targets of out edges) of the given vertex (right-hand operand) in the given graph (left-hand operand)<br>
</font>
</li>
<li>
<A name="sum">sum</A>
<br>
<font color="red">the sum of all the elements of the operand<br>the sum operator behavior depends on the nature of the operand</font>
</li>
<li>
<A name="tan">tan</A>
<br>
<font color="red">the trigonometic tangent of the operand (in decimal degrees).<br>
</font>
</li>
<li>
<A name="tanh">tanh</A>
<br>
<font color="red">the hyperbolic tangent of the operand (which has to be expressed in decimal degrees).<br>
</font>
</li>
<li>
<A name="target_of">target_of</A>
<br>
<font color="red">returns the target of the edge (right-hand operand) contained in the graph given in left-hand operand.<br>
</font>
</li>
<li>
<A name="text">text</A>
<br>
<font color="red">opens a file that a is a kind of text.<br>The file should have a text extension, cf. file type definition for supported file extensions.</font>
</li>
<li>
<A name="times">times</A>
<br>
</li>
<li>
<A name="to_gaml">to_gaml</A>
<br>
<font color="red">represents the gaml way to write an expression in gaml, depending on its type<br>
</font>
</li>
<li>
<A name="to_java">to_java</A>
<br>
<font color="red">represents the java way to write an expression in java, depending on its type<br>NOT YET IMPLEMENTED</font>
</li>
<li>
<A name="topology">topology</A>
<br>
<font color="red">casting of the operand to a topology.<br>
</font>
</li>
<li>
<A name="touches">touches</A>
<br>
<font color="red">A boolean, equal to true if the left-geometry (or agent/point) touches the right-geometry (or agent/point).<br>returns true when the left-operand only touches the right-operand. When one geometry covers partially (or fully) the other one, it returns false.</font>
</li>
<li>
<A name="towards">towards</A>
<br>
<font color="red">The direction (in degree) between the two geometries (geometries, agents, points) considering the topology of the agent applying the operator.<br>
</font>
</li>
<li>
<A name="transformed_by">transformed_by</A>
<br>
<font color="red">A geometry resulting from the application of a rotation and a translation (rigth-operand : point {angle(degree), distance} of the left-hand operand (geometry, agent, point)<br>
</font>
</li>
<li>
<A name="translated_by">translated_by</A>
<br>
<font color="red">A geometry resulting from the application of a translation by the right-hand operand distance to the left-hand operand (geometry, agent, point)<br>
</font>
</li>
<li>
<A name="triangle">triangle</A>
<br>
<font color="red">A triangle geometry which side size is given by the operand.<br>the centre of the triangle is by default the location of the current agent in which has been called this operator.</font>
</li>
<li>
<A name="triangulate">triangulate</A>
<br>
<font color="red">A list of geometries (triangles) corresponding to the Delaunay triangulation of the operand geometry (geometry, agent, point)<br>
</font>
</li>
<li>
<A name="truncated_gauss">truncated_gauss</A>
<br>
<font color="red">A random value from a normally distributed random variable in the interval ]mean - standardDeviation; mean + standardDeviation[.<br>
</font>
</li>
<li>
<A name="undirected">undirected</A>
<br>
<font color="red">the operand graph becomes an undirected graph.<br>the operator alters the operand graph, it does not create a new one.</font>
</li>
<li>
<A name="union">union</A>
<br>
<font color="red">The geometry resulting from the union of all geometries of agents of the operand-speciesreturns a new list containing all the elements of both operands without duplicated elements. Elements of this new list are sorted.<br>union is only defined with a list as left operand</font>
</li>
<li>
<A name="unknown">unknown</A>
<br>
<font color="red">returns the operand itself<br>
</font>
</li>
<li>
<A name="user_input">user_input</A>
<br>
</li>
<li>
<A name="variance">variance</A>
<br>
<font color="red">the variance of the elements of the operand. See &lt;A href="http://en.wikipedia.org/wiki/Variance"&gt;Variance&lt;/A&gt; for more details.<br>The operator casts all the numerical element of the list into float. The elements that are not numerical are discarded. </font>
</li>
<li>
<A name="weight_of">weight_of</A>
<br>
<font color="red">returns the weight of the given edge (right-hand operand) contained in the graph given in right-hand operand.<br>In a localized graph, an edge has a weight by default (the distance between both vertices).</font>
</li>
<li>
<A name="where">where</A>
<br>
<font color="red">a list containing all the elements of the left-hand operand that make the right-hand operand evaluate to true. <br>in the right-hand operand, the keyword each can be used to represent, in turn, each of the right-hand operand elements. </font>
</li>
<li>
<A name="with_max_of">with_max_of</A>
<br>
<font color="red">one of elements of the left-hand operand that maximizes the value of the right-hand operand<br>in the right-hand operand, the keyword each can be used to represent, in turn, each of the right-hand operand elements. </font>
</li>
<li>
<A name="with_min_of">with_min_of</A>
<br>
<font color="red">one of elements of the left-hand operand that minimizes the value of the right-hand operand<br>in the right-hand operand, the keyword each can be used to represent, in turn, each of the right-hand operand elements. </font>
</li>
<li>
<A name="with_optimizer_type">with_optimizer_type</A>
<br>
</li>
<li>
<A name="with_precision">with_precision</A>
<br>
<font color="red">round off the value of left-hand operand to the precision given by the value of right-hand operand<br>
</font>
</li>
<li>
<A name="with_weights">with_weights</A>
<br>
</li>
<li>
<A name="without_holes">without_holes</A>
<br>
<font color="red">A geometry corresponding to the operand geometry (geometry, agent, point) without its holes<br>
</font>
</li>
<li>
<A name="write">write</A>
<br>
<font color="red">marks the file so that read and write operations are allowed.<br>A file is created by default in read-only mode.</font>
</li>
</ul>
</body>
</html>
