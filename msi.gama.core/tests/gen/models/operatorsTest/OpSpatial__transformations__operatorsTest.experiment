/**
 *  OpOpSpatial__transformations__operatorsTest
 *  Author: automatic generator
 *  Description: Unity Test of operators belonging to category OpSpatial__transformations__operatorsTest.
 */

experiment OpSpatial__transformations__operatorsTestTests type: test {	

	
		test as_4_gridOp {
			matrix var0 <- self as_4_grid {10, 5}; 	// var0 equals the matrix of square geometries (grid with 4-neighborhood) with 10 columns and 5 lines corresponding to the square tessellation of the geometry of the agent applying the operator.

		}
	
		test as_gridOp {
			matrix var0 <- self as_grid {10, 5}; 	// var0 equals a matrix of square geometries (grid with 8-neighborhood) with 10 columns and 5 lines corresponding to the square tessellation of the geometry of the agent applying the operator.

		}
	
		test as_hexagonal_gridOp {
			list<geometry> var0 <- self as_hexagonal_grid {10, 5}; 	// var0 equals list of geometries (hexagonal) corresponding to the hexagonal tesselation of the first operand geometry

		}
	
		test at_locationOp {
			geometry var0 <- self at_location {10, 20}; 	// var0 equals the geometry resulting from a translation to the location {10, 20} of the left-hand geometry (or agent).

		}
	
		test bufferOp {

		}
	
		test cleanOp {
			geometry var0 <- clean(self); 	// var0 equals returns the geometry resulting from the cleaning of the geometry of the agent applying the operator.

		}
	
		test convex_hullOp {
			geometry var0 <- convex_hull(self); 	// var0 equals the convex hull of the geometry of the agent applying the operator

		}
	
		test CRS_transformOp {
			geometry var0 <- shape CRS_transform("EPSG:4326"); 	// var0 equals a geometry corresponding to the agent geometry transformed into the EPSG:4326 CRS
			geometry var1 <- CRS_transform(shape); 	// var1 equals a geometry corresponding to the agent geometry transformed into the current CRS

		}
	
		test enlarged_byOp {

		}
	
		test MinusOp {
			date var0 <- date('2000-01-01') - 200; 	// var0 equals date('2000-01-01')
			assert var0 = date('2000-01-01'); 
			rgb var1 <- rgb([255, 128, 32]) - 3; 	// var1 equals rgb([252,125,29])
			assert var1 = rgb([252,125,29]); 
			matrix var2 <- 3.5 - matrix([[2,5],[3,4]]); 	// var2 equals matrix([[1.5,-1.5],[0.5,-0.5]])
			assert var2 = matrix([[1.5,-1.5],[0.5,-0.5]]); 
			list<int> var3 <- [1,2,3,4,5,6] - [2,4,9]; 	// var3 equals [1,3,5,6]
			assert var3 = [1,3,5,6]; 
			list<int> var4 <- [1,2,3,4,5,6] - [0,8]; 	// var4 equals [1,2,3,4,5,6]
			assert var4 = [1,2,3,4,5,6]; 
			list<int> var5 <- [1,2,3,4,5,6] - 2; 	// var5 equals [1,3,4,5,6]
			assert var5 = [1,3,4,5,6]; 
			list<int> var6 <- [1,2,3,4,5,6] - 0; 	// var6 equals [1,2,3,4,5,6]
			assert var6 = [1,2,3,4,5,6]; 
			point var7 <- {1, 2} - {4, 5}; 	// var7 equals {-3.0, -3.0}
			assert var7 = {-3.0, -3.0}; 
			int var8 <- 1 - 1; 	// var8 equals 0
			assert var8 = 0; 
			int var9 <- 1.0 - 1; 	// var9 equals 0.0
			assert var9 = 0.0; 
			int var10 <- 3.7 - 1.2; 	// var10 equals 2.5
			assert var10 = 2.5; 
			int var11 <- 3 - 1.2; 	// var11 equals 1.8
			assert var11 = 1.8; 
			geometry var12 <- shape - 5; 	// var12 equals a geometry corresponding to the geometry of the agent applying the operator reduced by a distance of 5
			//geometry var13 <- geom1 - geom2; 	// var13 equals a geometry corresponding to difference between geom1 and geom2
			geometry var14 <- rectangle(10,10) - [circle(2), square(2)]; 	// var14 equals rectangle(10,10) - (circle(2) + square(2))
			assert var14 = rectangle(10,10) - (circle(2) + square(2)); 
			rgb var15 <- rgb([255, 128, 32]) - rgb('red'); 	// var15 equals rgb([0,128,32])
			assert var15 = rgb([0,128,32]); 
			float var16 <- date('2000-01-01') - date('2010-01-02'); 	// var16 equals 86400
			assert var16 = 86400; 
			point var17 <- {1, 2} - 4.5; 	// var17 equals {-3.5, -2.5, -4.5}
			assert var17 = {-3.5, -2.5, -4.5}; 
			point var18 <- {1, 2} - 4; 	// var18 equals {-3.0,-2.0,-4.0}
			assert var18 = {-3.0,-2.0,-4.0}; 
			map var19 <- ['a'::1,'b'::2] - ('b'::2); 	// var19 equals ['a'::1]
			assert var19 = ['a'::1]; 
			map var20 <- ['a'::1,'b'::2] - ('c'::3); 	// var20 equals ['a'::1,'b'::2]
			assert var20 = ['a'::1,'b'::2]; 
			point var21 <- -{3.0,5.0}; 	// var21 equals {-3.0,-5.0}
			assert var21 = {-3.0,-5.0}; 
			point var22 <- -{1.0,6.0,7.0}; 	// var22 equals {-1.0,-6.0,-7.0}
			assert var22 = {-1.0,-6.0,-7.0}; 
			map var23 <- ['a'::1,'b'::2] - ['b'::2]; 	// var23 equals ['a'::1]
			assert var23 = ['a'::1]; 
			map var24 <- ['a'::1,'b'::2] - ['b'::2,'c'::3]; 	// var24 equals ['a'::1]
			assert var24 = ['a'::1]; 
			int var25 <- - (-56); 	// var25 equals 56
			assert var25 = 56; 

		}
	
		test MultiplyOp {
			float var0 <- {2,5} * {4.5, 5}; 	// var0 equals 34.0
			assert var0 = 34.0; 
			rgb var1 <- rgb([255, 128, 32]) * 2; 	// var1 equals rgb([255,255,64])
			assert var1 = rgb([255,255,64]); 
			geometry var2 <- shape * {0.5,0.5,2}; 	// var2 equals a geometry corresponding to the geometry of the agent applying the operator scaled by a coefficient of 0.5 in x, 0.5 in y and 2 in z
			int var3 <- 1 * 1; 	// var3 equals 1
			assert var3 = 1; 
			point var4 <- {2,5} * 4; 	// var4 equals {8.0, 20.0}
			assert var4 = {8.0, 20.0}; 
			point var5 <- {2, 4} * 2.5; 	// var5 equals {5.0, 10.0}
			assert var5 = {5.0, 10.0}; 
			matrix<float> m <- (3.5 * matrix([[2,5],[3,4]]));	//m equals matrix([[7.0,17.5],[10.5,14]])
			geometry var7 <- circle(10) * 2; 	// var7 equals circle(20)
			assert var7 = circle(20); 
			float var8 <- 2.5 * 2; 	// var8 equals 5.0
			assert var8 = 5.0; 

		}
	
		test PlusOp {
			geometry var4 <- circle(5) + 5; 	// var4 equals circle(10)
			assert var4 = circle(10); 
			geometry var5 <- circle(5) + (5,32,#round); 	// var5 equals circle(10)
			assert var5 = circle(10); 
			point var6 <- {1, 2} + 4; 	// var6 equals {5.0, 6.0,4.0}
			assert var6 = {5.0, 6.0,4.0}; 
			point var7 <- {1, 2} + 4.5; 	// var7 equals {5.5, 6.5,4.5}
			assert var7 = {5.5, 6.5,4.5}; 
			geometry var8 <- circle(5) + (5,32); 	// var8 equals circle(10)
			assert var8 = circle(10); 
			point var9 <- {1, 2} + {4, 5}; 	// var9 equals {5.0, 7.0}
			assert var9 = {5.0, 7.0}; 
			date var10 <- date('2000-01-01') + 200; 	// var10 equals date('2000-01-01')
			assert var10 = date('2000-01-01'); 
			rgb var11 <- rgb([255, 128, 32]) + 3; 	// var11 equals rgb([255,131,35])
			assert var11 = rgb([255,131,35]); 
			int var12 <- 1 + 1; 	// var12 equals 2
			assert var12 = 2; 
			int var13 <- 1.0 + 1; 	// var13 equals 2.0
			assert var13 = 2.0; 
			int var14 <- 1.0 + 2.5; 	// var14 equals 3.5
			assert var14 = 3.5; 
			list<int> var15 <- [1,2,3,4,5,6] + 2; 	// var15 equals [1,2,3,4,5,6,2]
			assert var15 = [1,2,3,4,5,6,2]; 
			list<int> var16 <- [1,2,3,4,5,6] + 0; 	// var16 equals [1,2,3,4,5,6,0]
			assert var16 = [1,2,3,4,5,6,0]; 
			matrix var17 <- 3.5 + matrix([[2,5],[3,4]]); 	// var17 equals matrix([[5.5,8.5],[6.5,7.5]])
			assert var17 = matrix([[5.5,8.5],[6.5,7.5]]); 
			list<int> var18 <- [1,2,3,4,5,6] + [2,4,9]; 	// var18 equals [1,2,3,4,5,6,2,4,9]
			assert var18 = [1,2,3,4,5,6,2,4,9]; 
			list<int> var19 <- [1,2,3,4,5,6] + [0,8]; 	// var19 equals [1,2,3,4,5,6,0,8]
			assert var19 = [1,2,3,4,5,6,0,8]; 
			rgb var20 <- rgb([255, 128, 32]) + rgb('red'); 	// var20 equals rgb([255,128,32])
			assert var20 = rgb([255,128,32]); 
			string var21 <- "hello " + 12; 	// var21 equals "hello 12"
			assert var21 = "hello 12"; 
			//geometry var22 <- geom1 + geom2; 	// var22 equals a geometry corresponding to union between geom1 and geom2
			map var0 <- ['a'::1,'b'::2] + ['c'::3]; 	// var0 equals ['a'::1,'b'::2,'c'::3]
			assert var0 = ['a'::1,'b'::2,'c'::3]; 
			map var1 <- ['a'::1,'b'::2] + [5::3.0]; 	// var1 equals ['a'::1.0,'b'::2.0,5::3.0]
			assert var1 = ['a'::1.0,'b'::2.0,5::3.0]; 
			map var2 <- ['a'::1,'b'::2] + ('c'::3); 	// var2 equals ['a'::1,'b'::2,'c'::3]
			assert var2 = ['a'::1,'b'::2,'c'::3]; 
			map var3 <- ['a'::1,'b'::2] + ('c'::3); 	// var3 equals ['a'::1,'b'::2,'c'::3]
			assert var3 = ['a'::1,'b'::2,'c'::3]; 

		}
	
		test reduced_byOp {

		}
	
		test rotated_byOp {
			geometry var0 <- rotated_by(pyramid(10),45, {1,0,0}); 	// var0 equals the geometry resulting from a 45 degrees rotation along the {1,0,0} vector to the geometry of the agent applying the operator.
			geometry var1 <- self rotated_by 45; 	// var1 equals the geometry resulting from a 45 degrees rotation to the geometry of the agent applying the operator.

		}
	
		test scaled_byOp {

		}
	
		test scaled_toOp {
			geometry var0 <- shape scaled_to {10,10}; 	// var0 equals a geometry corresponding to the geometry of the agent applying the operator scaled so that it fits a square of 10x10

		}
	
		test simplificationOp {
			geometry var0 <- self simplification 0.1; 	// var0 equals the geometry resulting from the application of the Douglas-Peuker algorithm on the geometry of the agent applying the operator with a tolerance distance of 0.1.

		}
	
		test skeletonizeOp {
			list<geometry> var0 <- skeletonize(self); 	// var0 equals the list of geometries corresponding to the skeleton of the geometry of the agent applying the operator.

		}
	
		test smoothOp {
			geometry var0 <- smooth(square(10), 0.0); 	// var0 equals a 'rounded' square

		}
	
		test solidOp {

		}
	
		test split_geometryOp {
			list<geometry> var0 <- to_rectangles(self, {10.0, 15.0}); 	// var0 equals the list of the geometries corresponding to the decomposition of the geometry by rectangles of size 10.0, 15.0
			list<geometry> var1 <- to_rectangles(self, 10,20); 	// var1 equals the list of the geometries corresponding to the decomposition of the geometry of the agent applying the operator
			list<geometry> var2 <- to_squares(self, 10.0); 	// var2 equals the list of the geometries corresponding to the decomposition of the geometry by squares of side size 10.0

		}
	
		test split_linesOp {
			list<geometry> var0 <- split_lines([line([{0,10}, {20,10}]), line([{0,10}, {20,10}])]); 	// var0 equals a list of four polylines: line([{0,10}, {10,10}]), line([{10,10}, {20,10}]), line([{10,0}, {10,10}]) and line([{10,10}, {10,20}])

		}
	
		test to_GAMA_CRSOp {
			geometry var0 <- to_GAMA_CRS({121,14}); 	// var0 equals a geometry corresponding to the agent geometry transformed into the GAMA CRS
			geometry var1 <- to_GAMA_CRS({121,14}, "EPSG:4326"); 	// var1 equals a geometry corresponding to the agent geometry transformed into the GAMA CRS

		}
	
		test to_rectanglesOp {
			list<geometry> var0 <- to_rectangles(self, {10.0, 15.0}, true); 	// var0 equals the list of rectangles of size {10.0, 15.0} corresponding to the discretization into rectangles of the geometry of the agent applying the operator. The rectangles overlapping the border of the geometry are kept
			list<geometry> var1 <- to_rectangles(self, 5, 20, true); 	// var1 equals the list of rectangles corresponding to the discretization by a grid of 5 columns and 20 rows into rectangles of the geometry of the agent applying the operator. The rectangles overlapping the border of the geometry are kept

		}
	
		test to_squaresOp {
			list<geometry> var0 <- to_squares(self, 10, true); 	// var0 equals the list of 10 squares corresponding to the discretization into squares of the geometry of the agent applying the operator. The squares overlapping the border of the geometry are kept
			list<geometry> var1 <- to_squares(self, 10.0, true); 	// var1 equals the list of squares of side size 10.0 corresponding to the discretization into squares of the geometry of the agent applying the operator. The squares overlapping the border of the geometry are kept
			list<geometry> var2 <- to_squares(self, 10, true, 0.99); 	// var2 equals the list of 10 squares corresponding to the discretization into squares of the geometry of the agent applying the operator. The squares overlapping the border of the geometry are kept

		}
	
		test to_trianglesOp {

		}
	
		test transformed_byOp {
			geometry var0 <- self transformed_by {45, 0.5}; 	// var0 equals the geometry resulting from 45 degrees rotation and 50% scaling of the geometry of the agent applying the operator.

		}
	
		test translated_byOp {
			geometry var0 <- self translated_by {10,10,10}; 	// var0 equals the geometry resulting from applying the translation to the left-hand geometry (or agent).

		}
	
		test translated_toOp {

		}
	
		test triangulateOp {
			list<geometry> var0 <- triangulate(self); 	// var0 equals the list of geometries (triangles) corresponding to the Delaunay triangulation of the geometry of the agent applying the operator.
			list<geometry> var1 <- triangulate(self); 	// var1 equals the list of geometries (triangles) corresponding to the Delaunay triangulation of the geometry of the agent applying the operator.

		}
	
		test voronoiOp {
			list<geometry> var0 <- voronoi([{10,10},{50,50},{90,90},{10,90},{90,10}]); 	// var0 equals the list of geometries corresponding to the Voronoi Diagram built from the list of points.
			list<geometry> var1 <- voronoi([{10,10},{50,50},{90,90},{10,90},{90,10}], square(300)); 	// var1 equals the list of geometries corresponding to the Voronoi Diagram built from the list of points with a square of 300m side size as clip.

		}
	
		test with_precisionOp {
			point var0 <- {12345.78943, 12345.78943, 12345.78943} with_precision 2 ; 	// var0 equals {12345.79, 12345.79, 12345.79}
			assert var0 = {12345.79, 12345.79, 12345.79}; 
			float var1 <- 12345.78943 with_precision 2; 	// var1 equals 12345.79
			assert var1 = 12345.79; 
			float var2 <- 123 with_precision 2; 	// var2 equals 123.00
			assert var2 = 123.00; 
			geometry var3 <- self with_precision 2; 	// var3 equals the geometry resulting from the rounding of points of the geometry with a precision of 0.1.

		}
	
		test without_holesOp {
			geometry var0 <- solid(self); 	// var0 equals the geometry corresponding to the geometry of the agent applying the operator without its holes.

		}
	
}

	